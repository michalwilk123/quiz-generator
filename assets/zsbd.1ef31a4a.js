const a="ZSBD (KIO): Zarz\u0105dzanie Systemami Baz Danych",e=[{question:"W1: Jaka jest r\xF3\u017Cnica pomi\u0119dzy instancj\u0105 Oracle, baz\u0105 danych Oracle a serwerem Oracle?",type:"long_open",correct_answer:`Instancja - jest to tak naprawd\u0119 dana instalacja Serwera Oraclowego, mo\u017Cna mie\u0107 dost\u0119p do tylko jednej instancji na raz, jest to zbi\xF3r proces\xF3w dzia\u0142aj\u0105cych w tle i struktur pami\u0119ci, kt\xF3re umo\u017Cliwiaj\u0105 zarz\u0105dzanie baz\u0105 danych. Instacja nie potrzebuje posiada\u0107 Bazy Danych aby mog\u0142a pracowa\u0107. Do danej instancji mo\u017Ce by\u0107 podpi\u0119tych wiele baz danych oraclowych.
Baza Danych - zbi\xF3r fizycznych struktur sk\u0142adowania wszystkich danych u\u017Cytkownika i innych danych bazy danych. 
Serwer - na serwer oracle sk\u0142ada si\u0119: Instancja Oracle, Baza Danych Oracle (od 19c mo\u017Ce by\u0107 ich wiele (pluggable i kontenerowe), ale zawsze mo\u017Cemy by\u0107 pod\u0142\u0105czeni tylko do jednej), pliki dodatkowe  (np. pliki archiw\xF3w, plik do autoryzacji u\u017Cytkownik\xF3w specjalnych), procesy serwera s\u0142u\u017Cace dost\u0119powi do instancji, proces listenera oczekuj\u0105cy na nowe \u017C\u0105dania dost\u0119pu.`,scale:1},{question:"W1: Jaka jest r\xF3\u017Cnica mi\u0119dzy trybami dzia\u0142ania bazy: dedykowanym a wsp\xF3\u0142dzielonym?",type:"long_open",correct_answer:`Dedykowany tryb - dla ka\u017Cdego u\u017Cytkownika tworzony jest osobny proces serwera, kt\xF3remu przypisywane jest PGA (Program Global Area - fragment pami\u0119ci dedykowany tylko dla procesu serwera). Dla wielu konkurentych u\u017Cytkownik\xF3w, rozwi\u0105zanie to bywa bardzo obci\u0105\u017Caj\u0105ce dla zasob\xF3w serwera. Tryb ten jest idealny dla: administrowania bazy danych, przeprowadzanie backup\xF3w i recovery, batch processing i bulk load operations, Hurtowni Danych.

 Wsp\xF3\u0142dzielony tryb - po starcie instancji tworzona jest okre\u015Blona ilo\u015B\u0107 proces\xF3w serwera (mog\u0105 zosta\u0107 potem dodane je\u015Bli potrzeba). Wsp\xF3\u0142dzielony tryb dodatkowo sk\u0142ada si\u0119 z proces\xF3w dispatchera, kt\xF3ry mo\u017Ce odpowiada\u0107 za zarz\u0105dzanie sesji wielu u\u017Cytkownik\xF3w. U\u017Cytkownik jest pod\u0142\u0105czony do tego samego dispatchera podczas czasu trwania sesji. W wsp\xF3\u0142dzielonym trybie serwera, \u017C\u0105dania u\u017Cytkownika s\u0105 zawsze przekazywane do procesu serwera, kt\xF3ry jest najmniej obci\u0105\u017Cony.`,scale:1},{question:"W1: Jakie s\u0105 procesy instancji Oracle?",type:"long_open",correct_answer:`Mandatory:
PMON (process monitor process) - monitoruje wszystkie procesy, sprawdza czy kt\xF3ry\u015B z nich si\u0119 nie zawiesi\u0142 / nie dzia\u0142a, czy nie trzeba go zrestartowa\u0107, czy\u015Bci database buffer cache i zwalnia zasoby.

SMON (system monitor process) - sprawdza czy dane w bazie danych s\u0105 sp\xF3jne, odpowiada za consistency. B\u0119dzie inicjowa\u0107 odtworzenie instacji w momencie gdy dojdzie do np. chwilowego zaniku pr\u0105du, uszkodzenia dysku, po restarcie instancji SMON sprawdza czy dane na kt\xF3rych by\u0142 commit zosta\u0142y faktycznie wprowadzone, je\u017Celi baza jest w stanie niesp\xF3jnym, nast\u0119puje recovery.

DBWn (database writer process) - zapisuje bloki danych zawarte w buforze danych, do plik\xF3w danych, co jaki\u015B czas albo podczas checkpointu.

LGWR (log writer process) - serwisuje bloki dziennika powt\xF3rze\u0144 z bufora do plik\xF3w, w formie commita. Je\u015Bli log file jest pe\u0142ny inicjalizuje checkpoint.

CKPT (checkpoint process) - proces kt\xF3ry aktualizuje plik kontrolny i nag\u0142owki plik\xF3w danych z informacj\u0105 o checkpointach, w momencie checkpointu inicjalizuje DBWn aby zapisa\u0142 bloki danych na dysk.

MMON (manageability monitor process) - mechanizm, kt\xF3ry wykonuje zadania zwi\u0105zane z AWR. AWR (automatic workload repository) - w spos\xF3b automatyczny monitoruje stan bazy, obci\u0105\u017Cenie bazy na podstawie np. ustawionych alert\xF3w, treshold\xF3w. Automatycznie raportuje w narz\u0119dziu administracyjnym je\u015Bli metryki zostan\u0105 przekroczone.

MMNL (manageability monitor lite process) - zapisuje statystyki z bufora ASH (active session history) w SGA na dysk.

Additional:
RECO (recoverer process)  - w momencie gdy SMON stwierdzi, \u017Ce stan bazy jest niesp\xF3jny po jej uruchomieniu, RECO automatycznie naprawia b\u0142\u0119dy w dystrubuowanych transakcjach.
ARCn - archiver process(es) - copy online redo log files to offline storage after a redo log switch occurs; collect transaction redo data and transmit it to standby database destinations; ARCn processes exist only when the database is in ARCHIVELOG mode`,scale:1},{question:"W1: Jakie bufory wchodz\u0105 w sk\u0142ad instancji Oracle?",type:"long_open",correct_answer:`Buffer Cache - bufor danych - przechowuje bloki bazodanowe, kt\xF3re s\u0105 czytane z plik\xF3w danych, stosuj\u0105c mechanizm LRU (least recently used) (ostatnio u\u017Cywane bloki znajduj\u0105 si\u0119 w pami\u0119ci). Stosujemy go, poniewa\u017C je\u017Celi wielu u\u017Cytkownik\xF3w b\u0119dzie korzysta\u0142o z dok\u0142adnie z tych samych danych, to nie musimy odczytywa\u0107 ich z pliku tylko z tego bufora. Dla hurtowni danych nie jest on tak potrzebny ale dla transakcyjnych baz danych warto ustawi\u0107 jego warto\u015B\u0107 na tyle du\u017C\u0105 aby te wsp\xF3lnie u\u017Cywane bloki mie\u015Bci\u0142y si\u0119 w tym buforze.
Redo Log Buffer - dziennik powt\xF3rze\u0144 - s\u0142u\u017Cy on do tego aby przechowywa\u0107 dane potrzebne do wycofania transakcji, albo do zrobienia redo na zmianach do bazy danych. Zawiera on pliki dziennika powt\xF3rze\u0144, czyli kolejne wpisy zawieraj\u0105ce informacje o tym jakie zmiany zosta\u0142y zrobione na bazie danych (poprzednia warto\u015B\u0107 -> aktualna warto\u015B\u0107). Commit wymusza zapisanie danych z tego bufora do plik\xF3w dziennika powt\xF3rze\u0144, przy checkpoincie pliki dziennika powt\xF3rze\u0144 zapisywane s\u0105 do plik\xF3w danych.


Shared pool - bufor wsp\xF3\u0142dzielony, zawiera dane wsp\xF3\u0142dzielone mi\u0119dzy wielu u\u017Cytkownik\xF3w:
Library Cache - zawiera skompilowane plany wykonania zapyta\u0144, s\u0142u\u017Cy do przyspieszenia czasu wykonywania powtarzaj\u0105cych si\u0119 zapyta\u0144, je\u015Bli dane zapytanie posiada ju\u017C sw\xF3j plan w tym cachu to sprawdzane s\u0105 tylko uprawnienia i od razu zapytanie jest wykonywane. Jeden z najwa\u017Cniejszych bufor\xF3w, od jego rozmiaru zale\u017Cy szybko\u015B\u0107 wykonywania polece\u0144.
Data Dictionary Cache - cache przechowuj\u0105cy s\u0142ownik, powinien by\u0107 na tyle du\u017Cy aby s\u0142ownik si\u0119 w nim zmie\u015Bci\u0142, aby nie trzeba by\u0142o czyta\u0107 z pliku danych. 
Data Dictionary Cache - holds information about database objects; data dictionary is a collection of database tables and views containing reference information about the database, its structures, and its users; <- to jest z prezki
SQL Query Result Cache - nie zawiera blok\xF3w danych, ale rezultaty zapyta\u0144.
Pl/SQL Function Result Cache - zawiera rezultaty wykonanych funkcji PL/SQL
Large Pool - alokowany je\u015Bli pos\u0142ugujemy si\u0119 Large Objects.
Java Pool - s\u0142u\u017Cy do sk\u0142adowania procedur Java.`,scale:1},{question:"W1: Jaka jest r\xF3\u017Cnica mi\u0119dzy PGA i SGA?",type:"long_open",correct_answer:`SGA (System Global Area) - obszar pami\u0119ci zaalokowany dla instancji, znajduj\u0105 si\u0119 w nim bufory opisane w pytaniu 4.

PGA (Program Global Area) - znajduj\u0105 si\u0119 w nim procesy serwera, kt\xF3re s\u0105 poza instancj\u0105, po\u015Brednicz\u0105 one w dost\u0119pie do instancji, maj\u0105 w\u0142asne bufory.`,scale:1},{question:"W1: Na czym polega tryb NOARCHIVELOG?",type:"long_open",correct_answer:`ARCHIVELOG - archiwizowanie plik\xF3w dziennika powt\xF3rze\u0144 przed nadpisaniem ich. Produkcyjne bazy danych musz\u0105 pracowa\u0107 w tym trybie
NOARCHIVELOG - archiwizowanie plik\xF3w dziennika powt\xF3rze\u0144 nie wyst\u0119puje przed nadpisaniem ich. Czasami u\u017Cywany w hurtowniach danych.`,scale:1},{question:"W1: Wymie\u0144 rodzaje plik\xF3w bazy danych Oracle.",type:"long_open",correct_answer:`Pliki danych - zawieraj\u0105 bloki danych, s\u0142ownik, dane u\u017Cytkownik\xF3w, uprawnienia.
Plik kontrolny - pocz\u0105tkowo tylko jeden, ale POWINIEN by\u0107 multiplikowany , je\u015Bli plik kontrolny si\u0119 uszkodzi to nie ma mo\u017Cliwo\u015Bci dost\u0119pu do danych. Jest to kluczowy plik w dost\u0119pu do danych. Powinien by\u0107 powielany na r\xF3\u017Cnych dyskach. Zawiera on informacje o statusie danej bazy, ostatnim checkpoincie, adresy do plik\xF3w danych, adresy do plik\xF3w dziennika powt\xF3rze\u0144. 
Pliki dziennika powt\xF3rze\u0144 - kolejne wpisy zawieraj\u0105ce informacje o tym jakie zmiany zosta\u0142y zrobione na bazie danych (poprzednia warto\u015B\u0107 -> aktualna warto\u015B\u0107). Commit wymusza zapisanie danych z tego bufora do plik\xF3w dziennika powt\xF3rze\u0144, przy checkpoincie pliki dziennika powt\xF3rze\u0144 zapisywane s\u0105 do plik\xF3w danych.`,scale:1},{question:"W2: Dlaczego nale\u017Cy wykonywa\u0107 raport z instalacji SZBD Oracle?",type:"long_open",correct_answer:"Raport z instalacji Oracle zawiera wszystkie wybrane opcje, \u015Bcie\u017Cki, nazwy podczas instalacji instancji Oracle. Taki raport pomaga zindentyfikowa\u0107 gdzie co\u015B posz\u0142o nie tak.",scale:1},{question:"W2: Kt\xF3re domy\u015Blne ustawienia instalacji Oracle nale\u017Cy koniecznie zmieni\u0107?",type:"long_open",correct_answer:`w poprzednich wersjach oracle (w 19 automatycznie dezaktywowany), przy zdecydowaniu si\u0119 na instalacj\u0119 domy\u015Blnych schemat\xF3w nale\u017Cy zdezaktywowa\u0107 u\u017Cytkownika SCOTT/TIGER. (poniewa\u017C ma dost\u0119p do wszystkiego co maj\u0105 publiczni u\u017Cytkownicy, i mo\u017Cliwo\u015B\u0107 backdooru)
nale\u017Cy ustawi\u0107 inne has\u0142o dla ka\u017Cdego konta administracyjnego
nale\u017Cy stworzy\u0107 wi\u0119cej ni\u017C jedn\u0105 przestrze\u0144 tabel dla u\u017Cytkownik\xF3w
nale\u017Cy zmieni\u0107 folder w kt\xF3rym zapisuj\u0105 si\u0119 kopie pliku kontrolnego`,scale:1},{question:"W2: Na czym polega konfiguracja \u015Brodowiska sieciowego Oracle?",type:"long_open",correct_answer:"Na uruchomieniu Oracle Net Configuration assistant, nast\u0119pnie wybieramy, co by\u015Bmy chcieli skonfigurowa\u0107, w naszym przypadku by\u0142o to Local naming, nast\u0119pnie wybranie typu akcji jak\u0105 chcemy wykona\u0107 (stworzy\u0107, przetestowa\u0107, usun\u0105\u0107, zrekonfigurowa\u0107, zmieni\u0107 nazw\u0119), nast\u0119pnie wybieramy nazw\u0119 bazy danych, wybieramy protok\xF3\u0142 sieciowy (TCP, TCPS, IPC), nast\u0119pnie nazwa hosta i port, i nast\u0119pnie zdefiniowanie nazwy do po\u0142\u0105czenia si\u0119.",scale:1},{question:"W2: Jak Oracle mo\u017Cna dopasowa\u0107 do wspomagania bazy o charakterze transakcyjnym lub analitycznym (OLTP a OLAP)?",type:"long_open",correct_answer:`W wersji 19c posiadamy wyb\xF3r mi\u0119dzy dwoma typami konfiguracji bazy: General purpose/Transactional Processing, a Data Wearhousing. Je\u015Bli chcemy wspomaga\u0107 baz\u0119 o charakterze analitycznym powinni\u015Bmy wybra\u0107 opcj\u0119 Data Wearhousing, natomiast je\u015Bli interesuje nas baza o charakterze transakcyjnym, lub nie jeste\u015Bmy jeszcze pewni przeznaczenia naszej bazy, powinni\u015Bmy wybra\u0107 opcj\u0119 General purpose/Transactional Processing. Je\u015Bli chcemy sami dobra\u0107 parametry, to 2 najwa\u017Cniejsze wyr\xF3\u017Cniaj\u0105ce 2 powy\u017Csze charaktery baz to db_file_multiblock_read_count, kt\xF3ry powinien by\u0107 wi\u0119kszy w przypadku analitycznej bazy, oraz Pga_aggregate_target, kt\xF3ry r\xF3wnie\u017C powinien by\u0107 wi\u0119kszy w przypadku analitycznej bazy, w przypadku analitycznej bazy warto ustawi\u0107 jeszcze Star_transformation_enabled na TRUE.
W wypadku baz transakcyjnych warto rozwa\u017Cy\u0107 dodanie wi\u0119kszej ilo\u015B\u0107 pami\u0119ci dla obszaru PGA, w wypadku baz analitycznych, warto rozwa\u017Cy\u0107 dodanie wi\u0119kszej ilo\u015Bci pami\u0119ci dla obszaru SGA.`,scale:1},{question:"W2: Jakie s\u0105 statusy pracy instancji i do czego s\u0142u\u017C\u0105?",type:"long_open",correct_answer:`SHUTDOWN - instancja nie dzia\u0142a, mo\u017Ce zalogowa\u0107 si\u0119 do niej tylko u\u017Cytkownik SYS autoryzowany przez plik hase\u0142 (password file), mo\u017Cliwe jest r\xF3wnie\u017C uzyskanie dost\u0119pu do instancji w trybie NOLOG, i wtedy wykona\u0107 operacj\u0119 startup. 
NOMOUNT - instancja jest zainicjowana, ale nie jest pod\u0142\u0105czona baza danych, nie s\u0105 wczytane pliki kontrolne, w tym trybie mo\u017Cna operowa\u0107 na plikach kontrolnych.
MOUNT - w tym trybie pliki kontrolne s\u0105 otwarte, a pliki danych jeszcze nie, dlatego  jeste\u015Bmy w stanie operowa\u0107 na plikach danych, ale nie mo\u017Cliwe jest ju\u017C operowanie na plikach kontrolnych.
OPEN - w tym trybie baza danych i danych s\u0105 w pe\u0142ni otwarte, dlatego u\u017Cytkownicy mog\u0105 ju\u017C z niej korzysta\u0107
CLOSE - database closed and control files opened

Proces uruchamiania instancji: SHUTDOWN - NOMOUNT - MOUNT - OPEN;
Proces zamykania instancji: OPEN - CLOSE - NOMOUNT - SHUTDOWN;

Typy operacji shutdown:
SHUTDOWN NORMAL - zwyk\u0142y shutdown kt\xF3ry czeka a\u017C wszyscy u\u017Cytkownicy si\u0119 roz\u0142\u0105cz\u0105 przed zamkni\u0119ciem bazy, z powodu takiego warunku mo\u017Ce doj\u015B\u0107 do sytuacji w kt\xF3rej baza nie zostanie wy\u0142\u0105czona, bo zawsze kto\u015B b\u0119dzie pod\u0142\u0105czony
SHUTDOWN TRANSACTIONAL - uniemo\u017Cliwia otwarcie nowych transkacji, ale czeka na wszystkie bie\u017C\u0105ce transkacje aby si\u0119 zamkn\u0119\u0142y, mo\u017Ce doj\u015B\u0107 do sytuacji, \u017Ce u\u017Cytkownik zawi\u015Bnie podczas transakcji i je\u015Bli tryb autocommit jest wy\u0142\u0105czony to wszystko robione b\u0119dzie w obr\u0119bie transakcji
SHUTDOWN IMMEDIATE - od\u0142\u0105cza wszystkich u\u017Cytkownik\xF3w, zamyka wszystkie zapytania, zmiany kt\xF3re nie s\u0105 commited s\u0105 rollbackowane
SHUTDOWN ABORT - po prostu zamyka instancj\u0119, ignoruj\u0105c transakcje u\u017Cytkownik\xF3w, po tym sposobie wy\u0142\u0105czenia mo\u017Ce by\u0107 konieczno\u015B\u0107 wykonania recovery bazy danych
Najcz\u0119\u015Bciej wykonuje si\u0119 IMMEDIATE, czasami mo\u017Cna manualnie zabi\u0107 procesy u\u017Cytkownik\xF3w :) `,scale:1},{question:"W3: Do czego s\u0142u\u017Cy i jak si\u0119 stosuje mechanizm profil\xF3w?",type:"long_open",correct_answer:"Profile - zestaw parametr\xF3w, kt\xF3re dotycz\u0105 u\u017Cytkownika, ka\u017Cdy u\u017Cytkownik musi mie\u0107 profil, je\u015Bli nie podamy mu go przy tworzeniu, to zostanie przypisany domy\u015Blny. Profil ma swoj\u0105 nazw\u0119, domy\u015Blnie kontroluje polityk\u0119 autoryzacji, mo\u017Ce te\u017C kontrolowa\u0107 polityk\u0119 dost\u0119pu do zasob\xF3w, przy nie zaleca si\u0119 robienia tego (polityki dost\u0119pu do zasob\xF3w) przez profile tylko przez dedykowane narz\u0119dzie (Resource Manager, pakiet PL/SQL).",scale:1},{question:"W3: Do czego s\u0142u\u017Cy i jak si\u0119 stosuje mechanizm quota (w tym efekty obni\u017Cenia quoty)?",type:"long_open",correct_answer:"Okre\u015Bla do jakiego rozmiaru dane w schemacie u\u017Cytkownika mog\u0105 urosn\u0105\u0107 na danej przestrzeni tabel, a nie ile u\u017Cytkownik mo\u017Ce wstawi\u0107 danych. Je\u015Bli QUOTA zostanie zmniejszona w trakcie, nasze dane nie zostan\u0105 usuni\u0119te, ale nie b\u0119dziemy mogli wstawia\u0107 danych dop\xF3ki nie zmniejszymy rozmiaru naszych danych do rozmiaru QUOTY. Domy\u015Blnie wynosi 0 - zabrania wstawienia czegokolwiek, jest 1 wyj\u0105tek - chyba \u017Ce posiadamy uprawnienie UNLIMITED TABLESPACE.",scale:1},{question:"W3: Do czego s\u0142u\u017C\u0105 role, jak si\u0119 je stosuje i jakie maj\u0105 ograniczenia?",type:"long_open",correct_answer:`Role to s\u0105 'kube\u0142ki', tworz\u0105c role musimy j\u0105 tylko nazwa\u0107, b\u0119dzie to rola domy\u015Blna. Rola nie domy\u015Blna to taka, kt\xF3ra przyznaje uprawnienia dopiero gdy si\u0119 j\u0105 aktywuje. Rola s\u0142u\u017Cy po to aby wielu podobnym u\u017Cytkownikom nadawa\u0107 \u0142atwiej te same uprawnienia, usprawnia ona prac\u0119 administratora bazy, redukuj\u0105c pomy\u0142ki w wypadku wpisywania tych uprawnie\u0144 osobno dla ka\u017Cdego u\u017Cytkownika. Role nie zawieraj\u0105 si\u0119 w schemacie, nazwa roli powinna by\u0107 unikatowa - r\xF3\u017Cna od nazwy ka\u017Cdej innej roli i nazw u\u017Cytkownik\xF3w. Usuni\u0119cie u\u017Cytkownika kt\xF3ry stworzy\u0142 rol\u0119 nie usuwa roli, usuni\u0119cie u\u017Cytkownika, kt\xF3ry nada\u0142 nam uprawnienia, nie usuwa nam tych uprawnie\u0144. Uprawnie\u0144 nadanych przez role nie mo\u017Cemy u\u017Cywa\u0107 w poleceniach definiuj\u0105cych dane (widoki, skrypty PL/SQL) - musz\u0105 by\u0107 dodane manualnie.
Role to s\u0105 takie kube\u0142ki, poniewa\u017C w poleceniu GRANT mo\u017Cemy po prostu da\u0107 nazw\u0119 roli i b\u0119dzie to dzia\u0142a\u0107 jak nadanie komu\u015B jakiego\u015B uprawnienia, dla tego mo\u017Cna je traktowa\u0107 jako takie kube\u0142ki na uprawnienia.`,scale:1},{question:"W3: Wyja\u015Bnij r\xF3\u017Cnic\u0119 pomi\u0119dzy uprawnieniami systemowymi oraz uprawnieniami do obiekt\xF3w.",type:"long_open",correct_answer:`Z tego co rozumiem to uprawnienie systemowe daje nam og\xF3lne prawo do np. wykonywania operacji SELECT na tabelach, prawo do \u0142\u0105czenia si\u0119 z baz\u0105, tworzenia tabel. Posiada podzbi\xF3r nazwany Administrative privileges. Je\u015Bli kto\u015B posiada uprawnienie z opcj\u0105 ADMIN to mo\u017Ce je dawa\u0107 i zabiera\u0107 ka\u017Cdemu u\u017Cytkownikowi. W przypadku GRANT ANY PRIVILEGE mo\u017Cemy nie tylko t\u0105 permisj\u0119 ale te\u017C ka\u017Cd\u0105 inn\u0105 u ka\u017Cdego u\u017Cytkownika.
Uprawnienia do obiekt\xF3w, w por\xF3wnaniu do systemowych nie s\u0105 globalne tylko odnosz\u0105 si\u0119 do specyficznym schema obiekcie, np. mo\u017Cemy mie\u0107 prawo do tworzenia tabel z system privileges ale w danej przestrzeni tabel mo\u017Cemy go nie mie\u0107 i w takim wypadku nie mo\u017Cemy stworzy\u0107 tabeli. W\u0142a\u015Bciciel ma pe\u0142ne prawa do obiektu i mo\u017Ce je nadawa\u0107 dalej. Je\u015Bli chcemy doda\u0107 klucz obcy z kogo\u015B innego tabeli musimy r\xF3wnie\u017C posiada\u0107 uprawnienie REFERENCE do tej tabeli.
Synonimy - to chyba po prostu zamiennik dla nazwy tabeli, widoku, sekwencji itd itd.
W synonimach publicznych nie musimy podawa\u0107 schematu ?? nadanie uprawnienia do synonimu nadaje uprawnienie do obiektu.

Uprawnienia i widoki: je\u015Bli chcemy stworzy\u0107 widok musimy mie\u0107 uprawnienie do tworzenia widoku ale r\xF3wnie\u017C musimy mie\u0107 uprawnienie do select na danej tabeli. Aby dawa\u0107 innym uprawnienia do stworzonego widoku, musimy posiada\u0107 r\xF3wnie\u017C uprawnienia ustawione za pomoc\u0105 GRANT do tabeli z kt\xF3rej by\u0142 dany widok stworzony.Dzi\u0119ki widokom mo\u017Cemy zwi\u0119ksza\u0107 bezpiecze\u0144stwo po przez ograniczanie liczby danych jakie inni u\u017Cytkownicy mog\u0105 widzie\u0107.
Uprawnienia administracyjne: to s\u0105 po prostu kolejne systemowe uprawnienia tylko w charakterze stricte administracyjnym. SYSOPER daje mo\u017Cliwo\u015B\u0107 na startup, shutdown i zmiany tryb\xF3w bazy. SYSDBA ma w sobie SYSOPER, ma wszystkie uprawnienia z WITH ADMIN OPTION. U\u017Cytkownicy maj\u0105cy SYSDBA, SYSOPER, SYSAMS, SYSBACKUP, SYSDG maj\u0105 swoje has\u0142a w pliku hase\u0142. Pliki hase\u0142 mo\u017Cna tworzy\u0107 za pomoc\u0105 ORAPWD.`,scale:1},{question:"W3: Wyja\u015Bnij jakie efekty mo\u017Ce mie\u0107 odebranie uprawnienia i w jakich przypadkach te efekty mog\u0105 wyst\u0105pi\u0107 (odebranie uprawnie\u0144 systemowych, do obiekt\xF3w, roli).",type:"long_open",correct_answer:`Najpierw napisz\u0119 o grantach:
Grant systemowy:
nadajemy je poleceniem GRANT,
mo\u017Cemy doda\u0107 przywilej, rol\u0119, i przypisa\u0107 j\u0105 do roli, u\u017Cytkownika.

Grant na obiekcie:
Aby nada\u0107 komu\u015B uprawnienie, dany u\u017Cytkownik musi:
by\u0107 w\u0142a\u015Bcicielem obiektu || posiada\u0107 GRANT ANY OBJECT PRIVILEGE || GRANT ANY PRIVILEGE, || mie\u0107 privilege z WITH GRANT OPTION note to GRANT ANY PRIVILEGE, z t\u0105 komend\u0105 dzia\u0142ami w imieniu ownera obiektu, wi\u0119c je\u015Bli nadamy komu\u015B uprawnienia do kogo\u015B tabeli to b\u0119dzie to widoczne \u017Ce owner tabeli nada\u0142 temu komu\u015B uprawnienia a nie my.

Teraz o revokach:
Uprawnienia systemowe
aby zrevokowa\u0107 dany privilege albo rol\u0119 dany u\u017Cytkownik musi mie\u0107 j\u0105 nadan\u0105 z WITH ADMIN OPTION, albo mie\u0107 GRANT ANY PRIVILEGE albo GRANT ANY ROLE mo\u017Cemy zabiera\u0107 uprawnienia domy\u015Blnym rol\u0105 nie jeste\u015Bmy w stanie odebra\u0107 u\u017Cytkownikowi SYS \u017Cadnych uprawnie\u0144.
GRANT ANY OBJECT PRIVILEGE i GRANT ANY PRIVILEGE mo\u017Ce usun\u0105\u0107 tylko uprawnienia kt\xF3re nada\u0142 w\u0142a\u015Bciciel, poniewa\u017C revokuje je w jego imieniu
Dla obiekt\xF3w nie mo\u017Cna zrevokowa\u0107 uprawnie\u0144 z danej kolumny w\u0142a\u015Bcicielowi nie mo\u017Cna odebra\u0107 uprawnie\u0144.

Teraz do sedna pytania:
jak chcemy komu\u015B odebra\u0107 prawo do update jakiej\u015B tabeli to musimy najpierw da\u0107 revoke update, przez co je\u015Bli by\u0142y jakie\u015B inne tabele do jakich mieli\u015Bmy przywileje to je tracimy, i potem trzeba da\u0107 znowu update i osobno ka\u017Cd\u0105 tabel\u0119 do kt\xF3rej u\u017Cytkownik mia\u0142 uprawnienie je\u015Bli odbieramy komu\u015B uprawnienie kto nada\u0142 innym osobom uprawnienie, to wtedy te inne osoby r\xF3wnie\u017C trac\u0105 to uprawnienie GRANT ANY OBJECT PRIVILEGE i GRANT ANY PRIVILEGE mo\u017Ce usun\u0105\u0107 tylko uprawnienia kt\xF3re nada\u0142 w\u0142a\u015Bciciel, poniewa\u017C revokuje je w jego imieniu wszystkie sk\u0142adowane skrypty PL/SQL trac\u0105 wszystkie uprawnienia, wraz z u\u017Cytkownikiem w wypadku revoku je\u015Bli odbierzemy uprawnienie REFERENCE to nie zadzia\u0142a je\u015Bli nie u\u017Cywamy revoka kaskadowego, lub je\u015Bli u\u017Cytkownik skorzysta\u0142 z tego uprawnienia, aby zadzia\u0142a\u0142o nale\u017Cy u\u017Cy\u0107 go kaskadowo i wtedy wszystkie obiekty kt\xF3re nale\u017Ca\u0142y do danego u\u017Cytkownika ograniczenia typu FOREIGN KEY zostan\u0105 automatycznie usuni\u0119te ze wszystkich tabel danego u\u017Cytkownika`,scale:1},{question:"W3:Wyja\u015Bnij na czym polega mechanizm audytu i po co si\u0119 go stosuje",type:"long_open",correct_answer:`Po co audyt? Je\u015Bli posiadamy bardzo czu\u0142e dane, wtedy jeste\u015Bmy w stanie poci\u0105gn\u0105\u0107 odpowiedzialn\u0105 osob\u0119 do odpowiedzialno\u015Bc, kt\xF3ra nabroji w bazie. S\u0142u\u017Cy do monitorowania podejrzanych zachowa\u0144, sprawdzania aktywno\u015Bci bazy danych lub do wykrycia problem\xF3w z ustawieniami bezpiecze\u0144stwa. Po skomplikowanej zmianie uprawnie\u0144, za pomoc\u0105 polecenia audytu jeste\u015Bmy w stanie sprawdzi\u0107 czy nasze zmiany dzia\u0142aj\u0105 tak jak chcemy.
Typy audytu:
audyt polce\u0144, audyt wykorzystania pewnych rodzaj\xF3w polece\u0144, np. AUDIT TABLE, AUDIT CREATE ROLE.
audyt na konkretnym obiekcie, np. AUDIT INSERT ON table3
FGA, bardziej zaawansowane, mo\u017Cemy decydowa\u0107 czy chcemy tworzy\u0107 wpis audytu na SELECT na tabeli, ale mo\u017Cemy zdecydowa\u0107 czy chcemy zobaczy\u0107 na kt\xF3rych kolumn, a nawet wierszach, np. je\u015Bli kto\u015B robi SELECT na tabeli prezesa
Rezultaty audytu zapisywane s\u0105, w zale\u017Cno\u015Bci od parametru AUDIT_TRAIL (domy\u015Blnie NONE), je\u015Bli wpis 'chwyci' zapisywany jest on w schemacie pliku textowego lub XML lub w system event log, lub w bazie danych w specyficznych widokach.`,scale:1},{question:"W3: BONUS - uprawnienia w bazach PBD i CDB?",type:"long_open",correct_answer:`U\u017Cytkownicy oraz role COMMON albo LOCAL.
U\u017Cytkownicy systemowi domy\u015Bli typu SYS, SYSOPER s\u0105 u\u017Cytkownikami COMMON - widziani we wszystkich bazach. W ROOCIE i wszyskich pluggable. S\u0105 przechowywani w ROOCIE. Aby u\u017Cytkownik by\u0142 public musi mie\u0107 przedrostek c##
U\u017Cytkownicy lokalni, s\u0105 tylko w obr\u0119bie danych baz pluggable, unikalni tylko w obr\u0119bie danej bazie. Nazwy nie mog\u0105 si\u0119 zaczyna\u0107 z c##
Z rolami i profilami to samo, tylko common user musi posiada\u0107 common profile.
Dawanie priviliges. Mo\u017Cna lokalnie albo globalnie. U\u017Cytkownik common mo\u017Ce dosta\u0107 uprawnienie globalnie albo lokalnie. Rola mo\u017Ce dosta\u0107 uprawnienie lokalnie i globalnie. A rol\u0119 globaln\u0105 mo\u017Cemy nada\u0107 globalnie albo lokalnie. Role lokalnie nadawane tylko lokalnie. 
Audyty: mo\u017Cemy specyfikowa\u0107 czy chcemy globalnie czy lokalnie. Audyty globalne przechowywane w ROOCIE, lokalne w lokalnej bazie. Lokalny audyt odnosi si\u0119 do lokalnych i globalnych u\u017Cytkownik\xF3w.
Podczas zarz\u0105dzania bierzemy 2 rzeczy pod uwag\u0119: 
- niezawodno\u015B\u0107 i trwa\u0142o\u015B\u0107 przechowywannia danych
- preformance
Nigdy nie mo\u017Cemy mie\u0107 dw\xF3ch naraz, zawsze jaki\u015B tradeoff. Aby poprawi\u0107 performance, b\u0119dzie nadawa\u0107 wi\u0119cej uprawnie\u0144 do poszczeg\xF3lnych segment\xF3w i schemat\xF3w, ale nie b\u0119dzie poprawia\u0142o to niezawodno\u015Bci. `,scale:1},{question:"W4: Wymie\u0144 warstwy struktur sk\u0142adowania w bazie danych Oracle oraz struktury nale\u017C\u0105ce do poszczeg\xF3lnych poziom\xF3w.",type:"long_open",correct_answer:`logiczna/u\u017Cytkownika - schematy, w ramach schemat\xF3w tworzone komponenty przez u\u017Cytkownika
wewn\u0119trzna - Baza danych (nie ma logicznej bazy danych, baza danych rozumiana jest jak zbi\xF3r danych wszystkich u\u017Cytkownik\xF3w i dane systemowe) mo\u017Ce by\u0107 te\u017C pluggable albo kontenerowa, przestrzenie tabel, segmenty, ekstenty
fizyczna - pliki danych, przechowywane w systemie plik\xF3w oraz bloki dyskowe, ostatecznie wszystko jest sk\u0142adowane w plikach. Oracle ma mo\u017Cliwo\u015B\u0107 aby przechowywa\u0107 t\u0105 warstw\u0119 bez systemu operacyjnego. Mo\u017Cemy np. da\u0107 surowy dysk Oraclowi, i on samemu na wy\u0142\u0105czno\u015B\u0107, poniewa\u017C Oracle ma r\xF3wnie\u017C sw\xF3j system plik\xF3w.`,scale:1},{question:"W4: Om\xF3w, czym jest: schemat, przestrze\u0144 tabel, segment, ekstent, blok bazodanowy. Om\xF3w zale\u017Cno\u015Bci pomi\u0119dzy nimi",type:"long_open",correct_answer:`schemat - wszystkie obiekty bazodanowe nale\u017C\u0105ce do danego u\u017Cytkownika. Zawsze zak\u0142adany dla danego u\u017Cytkownika, nazwa schematu zawsze odpowiada nazwie u\u017Cytkownika, mo\u017Cemy podgl\u0105da\u0107 inne schematy je\u015Bli posiadamy wymagane uprawnienia. W ramach schematu, nie mo\u017Cna utworzy\u0107 czego\u015B poza schematem.
przestrze\u0144 tabel - Wydzielone obszary, ktore s\u0105 niezale\u017Cnie zarz\u0105dzane, z poziomu przestrzeni tabel zarz\u0105dzania si\u0119 plikami danych, s\u0105 r\xF3wnie\u017C predefiniowane przestrzenie tabel Przestrze\u0144 tabel tak naprawd\u0119 nie sk\u0142ada si\u0119 ze schemat\xF3w, poniewa\u017C dany u\u017Cytkownik mo\u017Ce mie\u0107 ustalon\u0105 quot\u0119 w r\xF3\u017Cnych przestrzeniach tabel, wi\u0119c tak naprawd\u0119 u\u017Cytkownik mo\u017Ce zmienia\u0107 dane nie w swoim schemacie, domy\u015Blnie u\u017Cytkownik przypisany do przestrzeni tabel users
segment - W momencie gdy u\u017Cytkownik pisze dowolne polecenie tworz\u0105ce logiczn\u0105 struktur\u0119 np. CREATE TABLE, na poziomie wewn\u0119trznym tworzonych jest jeden lub wi\u0119cej segment\xF3w. Je\u017Celi jest to zwyk\u0142a tabela, kt\xF3ra nie zawiera klucza g\u0142\xF3wnego zostanie stworzony jeden segment. Je\u015Bli zawiera klucz g\u0142\xF3wny zostan\u0105 stworzone 2 segmenty. Je\u015Bli tabela zawiera wbudowan\u0105 tabel\u0119 wewn\u0119trzn\u0105, lub zawiera Large Objects, wtedy na podstawie takiej tabeli zostanie stworzonych wiele segment\xF3w. Na poziomie segmentu mo\u017Cna zarz\u0105dza\u0107 alokowaniem tego jak dane mag\u0105 by\u0107 wpisywane w poszczeg\xF3lne pliki. Dla danego segmentu mo\u017Cemy skorzysta\u0107 z domy\u015Blnych ustawie\u0144, gdy wpiszemy polecenie CREATE TABLE gdzie zostanie utworzony segment z domy\u015Blnymi warto\u015Bciami przypisanymi do przestrzeni tabel, w kt\xF3rej jest on utworzony. Jest te\u017C mo\u017Cliwo\u015B\u0107 aby wyspecyfikowa\u0107 jak segment b\u0119dzie sk\u0142adowany i w jaki spos\xF3b b\u0119d\u0105 alokowane kolejne przestrzenie na ten segment. Tabele mog\u0105 by\u0107 dzielone na klastry i partycje, i wtedy segmenty b\u0119d\u0105 dzielone odpowiednio.
ekstent - jest to element alokacji, baza danych nie alokuje pojedy\u0144czych blok\xF3w, tylko jednostk\u0105 alokacji jest ekstent, mo\u017Ce si\u0119 sk\u0142ada\u0107 z jednego bloku, b\u0105d\u017A mo\u017Ce sk\u0142ada\u0107 si\u0119 z wi\u0119kszej ilo\u015Bci blok\xF3w bazodanowych (np. 16, 32). Na poziomie wewn\u0119trznym zarz\u0105dzamy ekstentami, zarz\u0105dzamy tym jakie s\u0105 rozmiary ekstent\xF3w, dla r\xF3\u017Cnych przesteni tabel mog\u0105 by\u0107 r\xF3\u017Cne rozmiary ekstent\xF3w, w definicji danego segmentu mo\u017Cemy zdefiniowa\u0107 jak du\u017Ce ekstenty b\u0119d\u0105 tworzone, nie musz\u0105 by\u0107 tych samych rozmiar\xF3w, np. jeden du\u017Cy, wiele ma\u0142ych.
blok bazodanowy - sk\u0142ada si\u0119 z okre\u015Blonej liczby blok\xF3w dyskowych, warto\u015B\u0107 domy\u015Blna - 8. Mo\u017Cemy r\xF3wnie\u017C zarz\u0105dza\u0107 na poziomie blok\xF3w. Od g\xF3ry blok\xF3w, w nag\u0142\xF3wku pisane s\u0105 transakcje, od do\u0142u wpisywane s\u0105 dane.

EXTENDED:
schemat - wszystkie elementy schemat\xF3w sk\u0142adowane s\u0105 w przestrzeniach tabel za pomoc\u0105 segment\xF3w. Odwo\u0142anie do schemat\xF3w mo\u017Ce by\u0107 jawne lub niejawne, np. przy CREATE TABLE mo\u017Cemy poda\u0107 lub nie nazw\u0119 schematu. Nazwy obiekt\xF3w nie musz\u0105 powtarza\u0107 si\u0119 w obr\u0119bie jednego schematu. 
database - kontenerowe i pluggable, w oracle 19 i 21 jest mo\u017Cliwo\u015B\u0107 \u017Ceby stworzy\u0107 tak jak kiedy\u015B jedn\u0105 du\u017C\u0105 baz\u0119 danych tak jak we wcze\u015Bniejszych wersjach oracle.
przestrze\u0144 tabel - mog\u0105 by\u0107 niezale\u017Cnie zarz\u0105dzane, mog\u0105 by\u0107 ustawiane read-only i on-line i off-line. Pojedy\u0144czy plik danych jest zawsze przypisany do jednej przestrzeni tabel!!!!!!!. Mamy kilka typ\xF3w przestrzeni tabel: na dane systemowe, na dane u\u017Cytkownika, undo, na dane tymczasowe. Ze wzgl\u0119d\xF3w niezawodno\u015Bciowych lepiej jest rozdziela\u0107 dane systemowe od danych u\u017Cytkownika, a tak\u017Ce rozdziela\u0107 dane u\u017Cytkownika i dane undo (je\u015Bli przestrze\u0144 tabel u\u017Cytkownika zostanie zape\u0142niona przez jaki\u015B atak to przestrze\u0144 undo nietkni\u0119ta). Poleca si\u0119 aby odzieli\u0107 indexy od tabel. Dzi\u0119ki temu mo\u017Cna podnie\u015B\u0107 performance. Absoultne minimum przestrzeni tabel to 3. Mo\u017Cna rozdzieli\u0107 za pomoc\u0105 tablespac\xF3w dane hurtowniane a transakcyjne. 
Mechanizm undo i redo - osobne segmenty sk\u0142aduj\u0105ce dane zanim zosta\u0142y zacommitowane, aby by\u0142a mo\u017Cliwa operacja rollback, jest to robione po to \u017Ceby zapewni\u0107 tryb izolacji transkacji midcommited, poniewa\u017C w tym trybie mo\u017Cna czyta\u0107 tylko dane kt\xF3re zosta\u0142y zacommitowane, dlatego jak inny u\u017Cytkownik b\u0119dzie czyta\u0142 dane z tabeli na kt\xF3rej jest transakcja do odczyta z undo. A redo (pliki dziennika powt\xF3rze\u0144) jest po to aby baz\u0119 danych w trybie niesp\xF3jnym aby powt\xF3rzy\u0107 lub wycofa\u0107 transakcj\u0119, kt\xF3re nie zako\u0144czy\u0142y si\u0119, nie zosta\u0142y zapisane podczas awarii bazy danych. S\u0105 te\u017C osobne buffory dla redo i undo.
zarz\u0105dzanie przestrzeni\u0105 tabel - odzielamy dane trwa\u0142e od danych tymczasowych, odzielamy dane szybkozmiennie od wolnozmiennych, odzielamy dane OLAP od OLTP, odzielamy tabele od index\xF3w, odzielamy historyczne partycje od obecnych.
segment - wewn\u0119trzna reprezentacja obiekt\xF3w tworzonych przez u\u017Cytkownika. Przypisany do konkretnej przestrzeni tabel. Mo\u017Cemy mie\u0107 typy segment\xF3w: typy zawieraj\u0105ce danych (table, table partition, cluster, nested table, LOB segment), typy zawieraj\u0105ce indexy (index, index-based table, index partition, LOB index), tymczasowy i undo.
ekstent - pojedy\u0144cza jednostka alokacji w plikach danych. W momencie kiedy segment jest tworzony, updatowany, dane jego s\u0105 usuwane, to kolejne extenty b\u0119d\u0105 tworzone. `,scale:1},{question:"W4: Wymie\u0144 i om\xF3w rodzaje plik\xF3w bazy danych, instancji i serwera Oracle.",type:"long_open",correct_answer:`Pliki danych - zawieraj\u0105 bloki danych, s\u0142ownik, dane u\u017Cytkownik\xF3w, uprawnienia. Przypisane s\u0105 do jednej przestrzeni tabel. Mog\u0105 posiada\u0107 dane z r\xF3\u017Cnych segment\xF3w. Alokacja przestrzeni w plikach danych jest robiona za pomoc\u0105 ekstent\xF3w. Posiada on nag\u0142owek i potem wolne i zaj\u0119te ekstenty.
Plik kontrolny - pocz\u0105tkowo tylko jeden, ale POWINIEN by\u0107 multiplikowany , je\u015Bli plik kontrolny si\u0119 uszkodzi to nie ma mo\u017Cliwo\u015Bci dost\u0119pu do danych. Jest to kluczowy plik w dost\u0119pu do danych. Powinien by\u0107 powielany na r\xF3\u017Cnych dyskach. Zawiera on informacje o statusie danej bazy, ostatnim checkpoincie, adresy do plik\xF3w danych, adresy do plik\xF3w dziennika powt\xF3rze\u0144. 
Pliki dziennika powt\xF3rze\u0144 - kolejne wpisy zawieraj\u0105ce informacje o tym jakie zmiany zosta\u0142y zrobione na bazie danych (poprzednia warto\u015B\u0107 -> aktualna warto\u015B\u0107). Commit wymusza zapisanie danych z tego bufora do plik\xF3w dziennika powt\xF3rze\u0144, przy checkpoincie pliki dziennika powt\xF3rze\u0144 zapisywane s\u0105 do plik\xF3w danych.
Password files - U\u017Cytkownicy maj\u0105cy SYSDBA, SYSOPER, SYSAMS, SYSBACKUP, SYSDG maj\u0105 swoje has\u0142a w pliku hase\u0142. Pliki hase\u0142 mo\u017Cna tworzy\u0107 za pomoc\u0105 ORAPWD.
Initialization parameter file - plik parametr\xF3w inicjalizacyjnych, w wersji binarnej, tak jest czytany przy starcie instancji, jest te\u017C wersja tekstowa dla cz\u0142owieka, kt\xF3r\u0105 mo\u017Cna zedytowa\u0107 i przekonwertowa\u0107 z powrotem na binarn\u0105. Cz\u0119\u015B\u0107 parametr\xF3w mo\u017Cna zmieni\u0107 w trakcie \u017Cycia instancji, czyli mo\u017Ce by\u0107 rozbie\u017Cno\u015B\u0107 mi\u0119dzy tym plikiem a konfiguracj\u0105 instancji. Trzeba w spos\xF3b przemy\u015Blany dokonywa\u0107 takich zmian w locie. Z biegem wersji jest tam coraz mniej inicjalizacyjnych parametr\xF3w, poniewa\u017C s\u0105 one dobierane automatycznie, albo ma domy\u015Blne warto\u015Bci.
Archive files - Kopie zapasowe (wszystkich rodzaj\xF3w), w tym automatycznie tworzone kopie plik\xF3w dziennika powt\xF3rze\u0144 (w trybie ARCHIVELOG)
Backup files - :) 
Logs - Logi systemowe, logi b\u0142\u0119d\xF3w, logi \u015Bledzenia (monitorowania) instancji`,scale:1},{question:"W4: Om\xF3w spos\xF3b alokacji ekstent\xF3w",type:"long_open",correct_answer:`Mamy jedn\u0105 przestrze\u0144 tabel (users), domy\u015Blnie jeden plik danych, wszystkie dane wszystkich u\u017Cytkownik\xF3w znajduj\u0105 si\u0119 w tym jednym pliku. Jak b\u0119dzie wygl\u0105da\u0142a alokacja ekstent\xF3w w tym pliku?
Jest jaki\u015B nag\u0142owek tego pliku.
U\u017Cytkownik 1 stworzy\u0142 tabel\u0119 1 - ekstent na tabel\u0119 1, 1 uzytkownika
U\u017Cytkownik 2 stworzy\u0142 tabel\u0119 2 - ekstent na tabel\u0119 2, 2 u\u017Cytkownika
U\u017Cytkownik do 1 tabeli wpisa\u0142 2 miliony danych - du\u017Cy ekstent na 2 miliony danych
Wszystko jest sk\u0142adowane \u0142\u0105cznie. I te dane nie s\u0105 wszystkie ko\u0142o siebie tylko s\u0105 rozrzucone. (te tiles poni\u017Cej do s\u0105 osobne ekstenty) wszystko to oczywi\u015Bcie mo\u017Ce by\u0107 dynamicznie alokowane i dealokowane. Mo\u017Ce by\u0107 tak \u017Ce mamy dane z tabeli 1,2,3. W momencie gdy te dane si\u0119 zmniejsz\u0105, dane wcze\u015Bniej zajmowane zostan\u0105 zwolnione. Dlatego mo\u017Ce wyst\u0119powa\u0107 problem fragmentacji. Je\u015Bli np. b\u0119dzie du\u017Co updat\xF3w i ekstent nagle si\u0119 zape\u0142ni, to mo\u017Ce wyst\u0105pi\u0107 sytuacja w kt\xF3rej b\u0119dzie trzeba nowe dane zapisa\u0107 do nowego ekstentu.`,scale:1},{question:"W4: Om\xF3w budow\u0119 i spos\xF3b parametryzowania bloku bazy danych Oracle.",type:"long_open",correct_answer:"sterowane za pomoc\u0105 parametr\xF3w instancji, na tych prezkach wbrew pozorom jest to dobrze wyja\u015Bnione.",scale:1},{question:"W4: Jakie r\xF3\u017Cnice w konfiguracji struktur sk\u0142adowania s\u0105 zalecane dla baz danych o charakterystyce OLAP i OLTP?",type:"long_open",correct_answer:"Du\u017Ce bloki danych, du\u017Ce ekstenty dla OLAP. Dla OLTP bloki danych i ekstenty b\u0119d\u0105 mniejsze. Dla OLTP nadawanie wi\u0119cej uprawnie\u0144 dla poszczeg\xF3lnych segment\xF3w i schemat\xF3w. Mo\u017Cna zwi\u0119kszy\u0107 liczb\u0119 transkacji na blokach baz danych - OLTP. Mniejsza dla OLAP. Mo\u017Cna rozdzieli\u0107 za pomoc\u0105 tablespac\xF3w dane hurtowniane a transakcyjne.",scale:1},{question:"W5: Wyja\u015Bnij r\xF3\u017Cnic\u0119 pomi\u0119dzy kopi\u0105 zapasow\u0105 struktur logicznych oraz fizycznych bazy danych",type:"long_open",correct_answer:"Logiczne s\u0142u\u017C\u0105 do tego aby robi\u0107 backupy danych u\u017Cytkownika, lub przenosi\u0107 dane mi\u0119dzy bazami danych, a fizyczne aby backupowa\u0107 fizyczne struktury, kt\xF3re Oracle u\u017Cywa do przechowywania danych, dlatego jest bardzo dobry w przypadku zgubionych plik\xF3w bazy danych. U\u017Cywaj\u0105 innych narz\u0119dzi RMAN - fizyczne, Oracle Data Pump - logiczne. Oba typy kopii zapasowych posiadaj\u0105 mo\u017Cliwo\u015B\u0107 przywr\xF3cenia bazy danych do przesz\u0142ego stanu, gdzie w fizycznej kopii zapasowej mo\u017Cemy wr\xF3ci\u0107 do dowolnego stanu o ile mamy odpowiednie backupy i zarchiwizowane pliki dziennika powt\xF3rze\u0144, a w przypadku logicznej wystarczy mie\u0107 plik z kt\xF3rego chcemy zaimportowa\u0107 dane wcze\u015Bniej wyeksportowane.",scale:1},{question:"W5: Om\xF3w podzia\u0142 kopi zapasowych (struktur fizycznych) ze wzgl\u0119du na format zapisu",type:"long_open",correct_answer:`Storage format
kopia obrazu - dos\u0142owna kopia pliku bazy danych, posiada puste bloki, mo\u017Cne zosta\u0107 zamieniony z oryginalnym plikiem
Backup set - u\u017Cywany aby zmniejszy\u0107 rozmiar backupu (wy\u017Cej mamy te puste bloki), poniewa\u017C dzia\u0142a jak kopia obrazu, ale pomija puste bloki. Nie mo\u017Ce by\u0107 u\u017Cywany do synthetic full backupu`,scale:1},{question:"W5: Om\xF3w podzia\u0142 kopi zapasowych (struktur fizycznych) ze wzgl\u0119du na zawarto\u015B\u0107",type:"long_open",correct_answer:`Contents
Full backup - wszystkie dane zapisane s\u0105 w plikach backupu, z pustymi blokami
Incremental backup 
Level 0 - taki sam jak full backup, tylko mo\u017Ce by\u0107 u\u017Cyty jako podstawa do nast\u0119pnych incremental backup\xF3w poziomu 1
Level 1 cumulative - tylko bloki kt\xF3re zmieni\u0142y si\u0119 od ostatniego Level 0 backup
Level 1 - tylko bloki od ostatniego inremental backupu - Level 0 albo 1
Synthetic full backup - Level 0 backup z backupami Level 1 zaaplikowanymi do niego`,scale:1},{question:"W5: Om\xF3w podzia\u0142 kopi zapasowych (struktur fizycznych) ze wzgl\u0119du na sp\xF3jno\u015B\u0107 danych (jakie kopie mo\u017Cna wykonywa\u0107 w jakim trybie dzia\u0142ania bazy?)",type:"long_open",correct_answer:`Consistency (nie wiem czy redo logi to to samo co dziennik powt\xF3rze\u0144/pliki dziennika powt\xF3rze\u0144 wi\u0119c u\u017Cy\u0142em bezpieczniejszej nazwy)
Consistent/offline backup
Consistent - przechowuje transaction-consistent data (nie wiem dok\u0142adnie co to jest ale zak\u0142adam \u017Ce dane musz\u0105 by\u0107 zgodne z transakcjami jakie s\u0105 wykonywane) (mo\u017Ce mo\u017Cna to nazwa\u0107 sp\xF3jnymi danymi)
Offline - Consistent omawiany wy\u017Cej nakada na nas warunek \u017Ceby baza danych by\u0142a wy\u0142\u0105czona aby m\xF3c przeprowadzi\u0107 consistent backup
nie potrzebuje media recovery po przywr\xF3ceniu oryginalnego pliku
jak przywr\xF3cimy baz\u0119 danych z pliku, to b\u0119dzie zawiera\u0142a ona tylko dane z momentu backupu
Inconsistent/online backup
Inconsistent - w por\xF3wnaniu do offline backupu, ten backup zawiera dane w transaction-inconsistent state (czyli pewnie nie wszystkie transakcje s\u0105 zako\u0144czone albo zacomittowane) (mo\u017Ce mo\u017Cna to nazwa\u0107 niesp\xF3jnymi danymi)
Online - mo\u017Ce by\u0107 wykonany podczas dzia\u0142ania bazy danych
ale przez to wymaga media recovery po przywr\xF3ceniu oryginalnego pliku
je\u015Bli media recovery zostanie u\u017Cyte to baza danych po przywr\xF3ceniu informacji z pliku nie tylko b\u0119dzie zawiera\u0142a dane z momentu backupu ale te\u017C dane do momentu awarii bazy danych
Media recovery
reapplies zmiany zapisane na incremental level 1 backupach i zarchiwizowanych i obecnych redo logach
zarchiwizowane i obecne redo logi s\u0105 bardzo wa\u017Cne, poniewa\u017C media recovery mo\u017Ce potem ich u\u017Cy\u0107 do repplying zmian z zacommitowanych transakcji kt\xF3rych nie ma w bazie danych przywr\xF3conej z pliku
Media recovery mo\u017Cliwa jest tylko gdy baza danych jest w trybie ARCHIVELOG, poniewa\u017C tylko tam zarchiwizowane redo logs b\u0119d\u0105 dost\u0119pne`,scale:1},{question:"W5: Om\xF3wi\u0107 podobie\u0144stwa i r\xF3\u017Cnice mechanizm\xF3w 'Point-in-time recovery' oraz 'Flashback database'",type:"long_open",correct_answer:`Point in time recovery:
umo\u017Cliwia na przywr\xF3cenie bazy danych do przesz\u0142ego stanu, o ile mamy odpowiednie backupy i zarchiwizowane pliki dziennika powt\xF3rze\u0144
Oracle Flashback:
daje mo\u017Cliwo\u015B\u0107 dost\u0119pu do poprzednich stan\xF3w danych bazy danych Oracle bez u\u017Cycia Point in time media recovery, co wi\u0105\u017Ce si\u0119 z tym \u017Ce nie musimy przywraca\u0107 ca\u0142ej bazy danych do poprzedniego stanu aby mie\u0107 dost\u0119p do poprzednich danych nie opiera si\u0119 on na plikach backupu tylko na undo operacji na danych, mo\u017Cemy w parametrze UNDO_RETENTION na jak d\u0142ugo b\u0119d\u0105 trzymane dane na undo

W obdydwu mechanizmach jeste\u015Bmy w stanie wr\xF3ci\u0107 do wybranego momentu w czasie, wersji, ale w flashbacku jeste\u015Bmy te\u017C w stanie dosta\u0107 wszystkie wersje z jakiego\u015B przedzia\u0142u czasu. W point in time i flashback database jeste\u015Bmy w stanie przywr\xF3ci\u0107 ca\u0142\u0105 baz\u0119 danych do danego punktu w czasie, w tym przypadku dzia\u0142aj\u0105 bardzo podobnie.`,scale:1},{question:"W5: Wymie\u0144 i podaj zastosowanie poszczeg\xF3lnych mechanizm\xF3w flashback",type:"long_open",correct_answer:`Flashback query - dzia\u0142a poprzez odzyskiwanie danych takie jakie by\u0142y w przesz\u0142o\u015Bci, aby je u\u017Cy\u0107 stosujemy po prostu SELECT z dodatkiem AS OF TIMESTAMP (czas). Mo\u017Cemy wydoby\u0107 dos\u0142owne dane z przesz\u0142o\u015Bci a nie stan (?bazy danych mo\u017Cliwie).
Flashback version query - tak jak poprzedni bierzemy dane za pomoc\u0105 SELECTU, ale w tym wypadku nie dostajemy danych ze specyficznego punktu w czasie tylko wszystkie wersje danych, kt\xF3re by\u0142y w bazie w danym odst\u0119pie czasu, wersji.
Flashback transaction query - dost\u0119pny poprzez widok FLASHBACK_TRANSACTION_QUERY. Widok ten przechowuje dane o wszystkich transakcjach i zmianach na danych u\u017Cytych w tych transakcjach. Mo\u017Cemy z tego widoku dosta\u0107 np. u\u017Cytkownika kt\xF3ry wykona\u0142 transakcje i kod SQLowy kt\xF3ry wycofa wszystkie zmiany zrobione w tej transakcji.
Flashback Table - przywraca dan\u0105 tabel\u0119 w wybrany punkt w czasie/SCN. Aby m\xF3c u\u017Cywa\u0107 Flashback table nale\u017C w\u0142\u0105czy\u0107 opcj\u0119 ROW MOVEMENT.
Flashback Drop - przywraca tabel\u0119 z kosza, kt\xF3ra zosta\u0142a zDROPowana. Aby ten flashback dzia\u0142a\u0142, musimy mie\u0107 ustawione RECYCLEBIN na ON, na samym pocz\u0105tku mo\u017Cemy zobaczy\u0107 w USER_RECYCLEBIN i czy tam jest jaka\u015B tabela i potem z binID do niej wr\xF3ci\u0107, albo mo\u017Cemy po prostu poda\u0107 nazw\u0119 tabeli.
Flashback database - u\u017Cywany za pomoc\u0105 RMANA, przywraca baz\u0119 danych do wybranego punktu w czasie/SCN.`,scale:1},{question:"W7: Poziomy optymalizacji wydajno\u015Bci w Oracle. Zasady optymalizacji wydajno\u015Bci.",type:"long_open",correct_answer:`poziom zapyta\u0144, mo\u017Cemy zmienia\u0107 samo zapytanie i zmienia\u0107 spos\xF3b wywo\u0142ania tego zapytania na poziomie aplikacji, na poziomie aplikacji mo\u017Cemy podzieli\u0107 jedno zapytanie na mniejsze, albo jedno du\u017Ce zapytanie scali\u0107, mo\u017Cemy cz\u0119\u015B\u0107 przetwarzania przerzuci\u0107 na maszyn\u0119 serwerow\u0105. Wi\u0119kszo\u015B\u0107 zapyta\u0144 (oko\u0142o 80%) to kwestia nieoptymalnych zapyta\u0144. Czasami nawet nie mo\u017Cna potrzeby na dane zapytanie.
poziom logicznej struktury bazy danych, normalizacja, aby unika\u0107 nadmiarowo\u015Bci aby nie powodowa\u0107 anomalii aktualizacji. Postacie normalne s\u0142u\u017Cy\u0142y do tego aby dane nie by\u0142y nadmiarowo przechowywane. Z perspektywy wydajno\u015Bci czasami celowo wprowadza si\u0119 redundancj\u0119 i nadmiarowo\u015B\u0107, aby zapewni\u0107 wydajno\u015B\u0107
konfiguracji \u015Brodowiska Oracle, dzia\u0142a instancji, dzia\u0142ania bazy danych, np. ilo\u015B\u0107 ekstent\xF3w, jak je alokowa\u0107, wi\u0119cej czy mniej, kiedy zwalnia\u0107 t\u0105 przestrze\u0144, jakie bufory i ich rozmiary, pami\u0119\u0107 operacyjna, algorytmy wykorzystania bufor\xF3w, liczba proces\xF3w serwera. Jest to bardzo wa\u017Cne dla bazy danych z danymi hurtownianymi i transakcyjnym, i w takim wypadku mo\u017Cliwie \u017Ce b\u0119dzie konieczne rozdzielenie tych danych mi\u0119dzy sob\u0105 fizycznie np. oddzielnie przestrzenie tabel z osobnymi charakterystykami.
\u015Brodowisko uruchomienia Oracle, brakuje zasob\xF3w pami\u0119ciowych, za ma\u0142o procesor\xF3w, problem systemu operacyjnego (windows wymuszaj\u0105cy aktualizacj\u0119), (wersje, patche, dodatkowe modu\u0142y) (Oracle), konfiguracja po\u0142\u0105czenia sieciowego (za ma\u0142o port\xF3w)`,scale:1},{question:"W7: Om\xF3w narz\u0119dzia optymalizacji w Oracle i obszary ich zastosowa\u0144.",type:"long_open",correct_answer:`AWR - automatic workload repository - mechanizm kt\xF3ry wyst\u0119puje od wersji 9, i s\u0142u\u017Cy do tego \u017Ceby gromadzi\u0107 statystyki o bazie. Odpowiednio ustatwiony, okresowo zbiera okre\u015Blone statystyki aby m\xF3c zobaczy\u0107 co si\u0119 dzieje. 
ADDM - automatic database diagnostic monitor - analizuje AWR i okresowo zg\u0142asza b\u0142\u0119dy administratorowi (Dzia\u0142anie proaktywne).
DBMS_STATS - we wcze\u015Bniejszych wersjach Oracle, obecnie te\u017C jest, kiedy\u015B mia\u0142 wi\u0119ksze znaczenie, w tej chwili s\u0142u\u017Cy aby zbiera\u0107 statystyki o poszczeg\xF3lnych tabelach
Oracle advisors: (to po prostu mo\u017Cemy nam wskaza\u0107 top 10 najbardziej obci\u0105\u017Caj\u0105ce baz\u0119 zapyta\u0144 
Memory advisor 
SQL tuning advisors
SQL access advisors
Partioning advisor
SQL performance analyzer
Alerty - automatyczne albo programowalne przez administratora, r\xF3wnie\u017C dzia\u0142anie proaktywne, aby okresowo sprawdza\u0107 i alarmowa\u0107

Trzeba by\u0107 rozwa\u017Cnym jak chodzi o tunowanie instancji Oracle, nie optymalizowa\u0107 je\u015Bli naprawd\u0119 nie wida\u0107 potrzeby.`,scale:1},{question:"W7: Na czym polega r\xF3\u017Cnica mi\u0119dzy akcyjn\u0105 a proaktywn\u0105 optymalizacj\u0105 wydajno\u015Bci?",type:"long_open",correct_answer:`Firefighting - sytuacja kiedy ju\u017C mamy zg\u0142oszony problem z wydajno\u015Bci\u0105, \u017Ce s\u0105 problemy z zapytaniami, z dost\u0119pem (dos\u0142ownie gasimy po\u017Car). 
EXTENDED:
Wa\u017Cne jest aby zapyta\u0107 si\u0119 o detale:
co dok\u0142adnie jest za wolne
kiedy i w jakich przypadkach i czy jest to powtarzalne
jakie poprawy s\u0105 spodziewane
czy inni maj\u0105 ten sam problem
co si\u0119 zmieni\u0142o od czasu kiedy dzia\u0142a\u0142o lepiej
czy na pewno trzeba wykona\u0107 to query
sprawdzi\u0107 reporty z danego okresu czasu z narz\u0119dzi opisanych w pytaniu 2 (ADDM jest bardzo u\u017Cyteczny)
Kolejno\u015B\u0107 diagnozowania b\u0142\u0119du - zapytanie -> aplikacja -> \u015Brodowisko Oracle -> instancja Oracle
Zmienia\u0107 tylko jedna rzecz na raz.
Najpierw testowa\u0107 na testowym serwerze.
Sprawdzi\u0107 improvement na testowym a potem na produkcyjnym serwerze.
Proaktywne - monitorowanie wydajno\u015Bci na bie\u017C\u0105co, aby zauwa\u017Cy\u0107 starzenie si\u0119 instancji, np. ze wzrostem wolumen\xF3w, u\u017Cytkownik\xF3w, danych wydajno\u015B\u0107 si\u0119 pogarsza i wtedy podj\u0105\u0107 dzia\u0142anie. U\u017Cywanie ADDM. U\u017Cywanie alert\xF3w.
EXTENDED:
planujemy, pr\xF3bujemy zaprojektowa\u0107 wydajno\u015B\u0107
Co mo\u017Cna zrobi\u0107?
Jak analizujemy dzia\u0142anie instancji zawsze musimy poda\u0107 pocz\u0105tek i koniec czasu w jakim chcemy j\u0105 analizowa\u0107. 
Mo\u017Cna obni\u017Ca\u0107 obci\u0105\u017Cenie w danych okresach czasu. Mo\u017Ce zarz\u0105dza\u0107 zasobami w zale\u017Cno\u015Bci od czasu. Zr\xF3wnoleglanie.
(wi\u0119cej nie m\xF3wi\u0142a w por\xF3wnaniu z tym co jest na slajdach)
mo\u017Cna sprawdza\u0107 te\u017C zapytania w krytycznych momentach czasowych, oraz sprawdza\u0107 plany zapytania zapyta\u0144.
Wa\u017Cne te\u017C jest u\u017Cywanie tych wszystkich raport\xF3w, alert\xF3w z tych narz\u0119dzi z pytania nr 2.`,scale:1},{question:"W7: Jak jest przetwarzane w Oracle: zapytanie SELECT, polecenia DML, polecenie COMMIT.",type:"long_open",correct_answer:`SELECT - 
Parsowanie: 
Poszukiwanie w poprzednich wykonywanych poleceniach w Shared Pool w Library Cache (plan zapytania wcze\u015Bniej wybrany, zoptymalizowany, wybrany spo\u015Br\xF3d wielu). Wa\u017Cne aby zbi\xF3r tych przygotowanych wcze\u015Bniej zapyta\u0144 mie\u015Bci\u0142 si\u0119 w Shared pool.
sprawdzenie sk\u0142adni - sprawdzenie poprawno\u015Bci (mo\u017Ce nawet jest wcze\u015Bniej np. przez SQL developera?????)
sprawdzenie nazewnictwa obiekt\xF3w, u\u017Cywa s\u0142ownika danych Data dictionary Cache
blokowanie obiekt\xF3w u\u017Cywanych w czasie analizy, nie mo\u017Cna ich modyfikowa\u0107 podczas query, nie b\u0119d\u0105 na nich dzia\u0142a\u0107 polecenia DDL
sprawdzenie uprawnie\u0144, znowu z Data dictionary Cache
tworzenie planu wykonania zapytania, tworzy wiele wariant\xF3w, ocenia je i wybiera najlepszy z nich i zapisuje w buforze
Wykonanie
sprawdza dane w buforze danych (LRU)
czytanie danych z plik\xF3w danych lub bufora danych
otwarcie kursora (????)
fetchowanie(proces serwera)
sortowanie(proces serwera)
wys\u0142anie z kursora do procesu klienta (pr\u0119dko\u015B\u0107 zale\u017Cy od konfiguracji \u015Brodowiska sieciowego)
Przetwarzanie zapytania DML 
Analiza - jak w zapytaniach 
Wykonanie - 
je\u017Celi dane nie s\u0105 w buforze, nast\u0119puje odczyt danych z plik\xF3w i zapisanie ich do bufor\xF3w danych i wycofania; 
za\u0142o\u017Cenie blokad na rekordy; 
modyfikacja bufora danych - nowe warto\u015Bci i bufora wycofania - poprzednie warto\u015Bci; 
('brudny blok' - dane w pami\u0119ci r\xF3\u017Cni\u0105 si\u0119 od danych w plikach na dysku).
rejestracja zmian w buforze dziennika powt\xF3rze\u0144 (kt\xF3re bloki w obu buforach s\u0105 zmienione); 
COMMIT 
Przetwarzanie polecenia COMMIT 
mechanizm 'fast commit' 
numer SCN - system change number 
kroki: 
Zapis o commitcie(?) z numerem SCN (system change number) w buforze dziennika powt\xF3rze\u0144 (REDO LOG BUFFER) 
LGWR zapisuje bufor dziennika powt\xF3rze\u0144 do pliku (REDO LOG)  
U\u017Cytkownik jest informowany o zako\u0144czeniu commit 
Zapis o zako\u0144czeniu commit\u2019u. 
zapis danych do plik\xF3w jest niezale\u017Cny od polecenia commit, mo\u017Ce nast\u0105pi\u0107 przed lub po wykonaniu commit. 
zapis tylko do dziennika powt\xF3rze\u0144 sprzyja wydajno\u015Bci, poniewaz zapis do plik\xF3w danych jest kosztowny i inne transakcje mog\u0105 mie\u0107 wi\u0119kszy priorytet i czeka\u0107, przez co oracle wybierze czas na zapisanie tego do pliku, tak aby by\u0142o najwydajniej 
When a user issues a COMMIT statement, LGWR puts a commit record in the redo log buffer and writes it to disk immediately, along with the transaction's redo entries. The corresponding changes to data blocks are deferred until it is more efficient to write them. This is called a fast commit mechanism. The atomic write of the redo entry containing the transaction's commit record is the single event that determines the transaction has committed. Oracle returns a success code to the committing transaction, although the data buffers have not yet been written to disk`,scale:1},{question:"W7: Analiza planu zapytania - cele, metody, operacje.",type:"long_open",correct_answer:`Rola PLUSTRACE wymaga jest do zobaczenia planu wykonania zapytania.
Warto czy\u015Bci\u0107 tabele plan\xF3w wykonania zapytania co jaki\u015B czas.
Przez \u015Bledzenie zapyta\u0144, ich wydajno\u015B\u0107 mo\u017Ce spa\u015B\u0107 o 25%
Czytamy od prawej do lewej z g\xF3ry na d\xF3\u0142.
Parametry jakie mo\u017Cemy spotka\u0107:
Table access full - fajne je\u015Bli tabela jest ma\u0142a, s\u0142aba je\u015Bli jest du\u017Ca, warto rozwa\u017Cy\u0107 wprowadzenie indeks\xF3w
Table access by index rowid - najbardziej efektywna metoda, idziemy do fizycznego adresu wiersza
index unique scan - szybszy ni\u017C range scan bo tam jest wiele \u015Bcie\u017Cek a w tym przechodzimy po jakim\u015B B drzewie
index range scan - mo\u017Ce to oznacza\u0107 \u017Ce indeks jest nieodpowiednie utworzony.
Hash key access - w przypadku partycji
Z\u0142\u0105czenia:
nested loop - jedna tabela i jedziemy po wierszu, i dla ka\u017Cdego wiersza przeje\u017Cd\u017Camy wszystkie wiersze z drugiej tabeli je\u015Bli odnosimy si\u0119 to wielu tabel to nieefektywne, je\u015Bli te tabele s\u0105 ma\u0142e to spoko, oceniamy na podstawie ilo\u015Bci u\u017Cytych wierszy
sort merge join - najpierw sortujemy i po pewnym atrybucie z\u0142\u0105czamy dwie tabele, je\u017Celi s\u0105 podonych rozmiar\xF3w soft merge join szybszy, je\u015Bli r\xF3\u017Cnych to nested loop lepszy
hash join - ?????
cartesian join - z\u0142\u0105czamy wszystko ze wszyskim, jest prawdopodobie\u0144stwo \u017Ce b\u0142\u0105d ludzki, szukamy skanowania du\u017Cych tabel wtedy
Czego szukamy w planach wykonania zapytania?
b\u0142\u0119d\xF3w cz\u0142owieka
szukamy b\u0142\u0119d\xF3w optymalizatora, je\u015Bli wykonujemy du\u017Ce \u0142adowanie danych, to warto zaktualizowa\u0107 statystyki aby zaktualizowa\u0107 plany wykoania zapyta\u0144
szukamy zalet Oracla, jak je znajdziemy to wiemy \u017Ce zapytanie jest spoko

Co powinno nas niepokoi\u0107?
- du\u017Ce skany tabel
- cartesian joiny
- unselective range scan ?? (brak indexu)
- z\u0142y order join\xF3w
- zagnie\u017Cd\u017Cone p\u0119tle
- nieefektywne filtry

Dobre strony zapyta\u0144:
- jak najwcze\u015Bniejsza selekcja
- jak najszybsza projekcja
- joiny najp\xF3\u017Aniej jak mo\u017Cna (kartezjany szczeg\xF3lnie)
- unia dopiero po wszystkich joinach
- kolejno\u015B\u0107 z\u0142\u0105cze\u0144 odpowiada liczby wierszy`,scale:1},{question:"W7: R\xF3\u017Cnica mi\u0119dzy optymalizatorem kosztowym a regu\u0142owym",type:"long_open",correct_answer:`Regu\u0142owy - do oracla 9i, je\u017Celi selektywno\u015B\u0107 zapytania jest powy\u017Cej 50% to skanuj ca\u0142\u0105 tabel\u0119, a nie u\u017Cywaj indeks\xF3w, je\u015Bli selektywno\u015B\u0107 zapytania jest mniejsza ni\u017C 10% u\u017Cyj indeks\xF3w. Optymalizacja zapytania na podstawie regu\u0142. Mamy wi\u0119ksz\u0105 kontrol\u0119 nad tym co robimy.
Kosztowy - od oracla 7, teraz ju\u017C jedyny, ma statystyki na tabelach, bierze je pod uwag\u0119, oblicza selektywno\u015B\u0107, ilo\u015B\u0107 zwracanych wierszy i sam dobiera regu\u0142y (dynamicznie). Uwzgl\u0119dnia ca\u0142\u0105 konfiguracj\u0119 instancji. Szacuje koszt i wybiera plan o najmniejszym koszcie. Jest to automat.`,scale:1}];var n={name:a,quiz_elements:e};export{n as default,a as name,e as quiz_elements};
