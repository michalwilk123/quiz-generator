const a="Interaktywne Systemy Programowalnych",e=[{question:"Wymie\u0144 trzy kategorie uk\u0142ad\xF3w programowalnych (podzia\u0142 pod wzgl\u0119dem z\u0142o\u017Cono\u015Bci architektury) i scharakteryzuj kr\xF3tko ka\u017Cd\u0105 z nich.",type:"long_open",correct_answer:`a. SPLD - Simple Programmable Logic Devices: 
Najprostsze i najstarsze uk\u0142ady programowalne. Ich g\u0142\xF3wnym 
komponentem jest matryca bramek odpowiedzialna za przetwarzanie sygna\u0142\xF3w. W tej kategori uk\u0142ad\xF3w zawieraj\u0105 si\u0119 takie podkategorie jak: PROM, PLA, PAL, GAL. 
b. CPLD - Complex Programmable Logic Devices: 
S\u0105 bardziej z\u0142o\u017Con\u0105 wersj\u0105 uk\u0142ad\xF3w SPLD, oferuj\u0105 wi\u0119ksz\u0105 pojemno\u015B\u0107 logiczn\u0105. Sk\u0142adaj\u0105 si\u0119 z wielu blok\xF3w podobnych do uk\u0142ad\xF3w SPLD po\u0142\u0105czonych magistralami w jedn\u0105 struktur\u0119. Ko\u0144c\xF3wki I/O uk\u0142adu maj\u0105 po\u0142\u0105czenie zar\xF3wno z blokami jak i z magistral\u0105. 
c. FPGA - Field-Programmable Gate Array: 
Uk\u0142ady oparte o koncepcj\u0119 morza bramek (ang. sea of gates), s\u0105 zbudowane z blok\xF3w z bramkami logicznymi przedzielonych 
po\u0142\u0105czeniami programowalnymi. Bloki z biegiem czasu stawa\u0142y si\u0119 coraz bardziej z\u0142o\u017Cone co umo\u017Cliwi\u0142o zmniejszenie op\xF3\u017Anie\u0144 uk\u0142ad\xF3w wynikaj\u0105cych z du\u017Cej liczby po\u0142\u0105cze\u0144 mi\u0119dzy blokami. Z tego samego powodu udoskonalano tak\u017Ce po\u0142\u0105czenia mi\u0119dzy kom\xF3rkami (np. poprzez routing).`,scale:10},{question:"Jakiej kategorii uk\u0142ad\xF3w programowalnych dotyczy podzia\u0142 na: coarse grade, medium grade i fine grade. Scharakteryzuj kr\xF3tko cechy wy\u017Cej wymienionych rodzaj\xF3w uk\u0142ad\xF3w. ",type:"long_open",correct_answer:`Podzia\u0142 dotyczy architektur uk\u0142ad\xF3w FPGA, a poszczeg\xF3lne kategorie przedstawiaj\u0105 si\u0119 nast\u0119puj\u0105co: 
a. fine grade (drobne uziarnienie) : 
Bloki po\u0142\u0105czone ze sob\u0105 maj\u0105 bardzo prost\u0105 budow\u0119, sk\u0142adaj\u0105 si\u0119 z prostego uk\u0142adu programowalnego (2-3 wej\u015Bcia) i przerzutnika. Mimo elastyczno\u015Bci rozwi\u0105zania, nadal wyst\u0119puj\u0105 w uk\u0142adach o takiej architekturze du\u017Ce op\xF3\u017Anienia. 
b. medium grade (\u015Brednie uziarnienie): 
Bloki o bardziej z\u0142o\u017Conej budowie ni\u017C fine grade opisuj\u0105 uk\u0142ady o wi\u0119kszej ziarnisto\u015Bci. Wykorzystuje si\u0119 w nich multipleksery, czyli po\u0142\u0105czenia aktywne, co zmniejszy\u0142o op\xF3\u017Anienia. 
c. coarse grade (grube uziarnienie): 
Bloki o najwi\u0119kszej z\u0142o\u017Cono\u015Bci, charakteryzuj\u0105ce si\u0119 bardzo du\u017C\u0105 liczb\u0119 wej\u015B\u0107 (np. 32). Budowa wewn\u0119trzna bloku jest 
skomplikowana, za to op\xF3\u017Anienia wyst\u0119puj\u0105ce w uk\u0142adach je 
wykorzystuj\u0105cych zmala\u0142y.`,scale:10},{question:"Jaki rodzaj pami\u0119ci konfiguracji dominuje w uk\u0142adach CPLD, a jaki w FPGA. ",type:"long_open",correct_answer:`W uk\u0142adach CPLD dominuj\u0105 pami\u0119ci nieulotne z mo\u017Cliwo\u015Bci\u0105 elektrycznego kasowania EEPROM (E2PROM) oraz FLASH. 
W uk\u0142adach FPGA dominuje pami\u0119\u0107 ulotna wymagaj\u0105ca ka\u017Cdorazowego programowania po ponownym w\u0142\u0105czeniu zasilania - static RAM - SRAM.`,scale:10},{question:"Wymie\u0144 rodzaje pami\u0119ci konfiguracji",type:"long_open",correct_answer:`Rodzaje pami\u0119ci konfiguracji: 
a. PROM - pami\u0119\u0107 programowalna z mo\u017Cliwo\u015Bci\u0105 pojedynczego zaprogramowania przepaleniem po\u0142\u0105cze\u0144 lub maskowaniem.
    - fuse (bezpiecznik/roz\u0142\u0105czenie) - wyst\u0119puj\u0105 po\u0142\u0105czenia bramki ze wszystkimi sygna\u0142ami w uk\u0142adzie, te kt\xF3re nie s\u0105 wykorzystane zostaj\u0105 przepalone i w efekcie pozosta\u0142e \u015Bcie\u017Cki decyduj\u0105 o pracy uk\u0142adu. 
    - anti-fuse (anty-bezpiecznik/zwarcie) - \u017Caden sygna\u0142 nie jest po\u0142\u0105czony z bramk\u0105, po\u0142\u0105czenia z tymi sygna\u0142ami, kt\xF3re maj\u0105 by\u0107 wykorzystane zostaj\u0105 wygenerowane (zwarte) i one decyduj\u0105 o pracy uk\u0142adu. 
b. EPROM - pami\u0119\u0107 programowalna z mo\u017Cliwo\u015Bci\u0105 kasowania zapisanej konfiguracji poprzez wystawienie na dzia\u0142anie \u015Bwiat\u0142a UV. 
c. EEPROM/FLASH - pami\u0119\u0107 programowalna z mo\u017Cliwo\u015Bci\u0105 elektrycznego (programowalnego) kasowania zawarto\u015Bci 
d. SRAM - w po\u0142\u0105czeniu z tranzystorem umo\u017Cliwia utworzenie po\u0142\u0105czenia programowalnego.`,scale:10},{question:"W uk\u0142adzie Spartan3E w jednej kom\xF3rce LUT mo\u017Cna zrealizowa\u0107 pewne funkcje logiki. Podaj ile maksymalnie zmiennych wej\u015Bciowych mo\u017Ce mie\u0107 dowolna funkcja logiczna zrealizowana w jednej kom\xF3rce LUT, ile maksymalnie zmiennych wej\u015Bciowych mo\u017Ce mie\u0107 dowolna funkcja logiczna zrealizowana za pomoc\u0105 jednego Slice oraz ile maksymalnie wej\u015B\u0107 mog\u0105 mie\u0107 pewne funkcje logiczne wykonane w oparciu o jeden Slice. Dowolna funkcja logiczna oparta o jeden: ",type:"long_open",correct_answer:`- LUT - maksymalnie 4 zmienne wej\u015Bciowe, 
- Slice - maksymalnie 5 zmiennych wej\u015Bciowych. 
Pewne funkcje logiczne oparte o jeden Slice - maksymalnie 9 zmiennych wej\u015Bciowych.`,scale:10},{question:"Wymie\u0144 parametry ko\u0144c\xF3wki I/O uk\u0142adu Spartan3E kt\xF3re mo\u017Cna konfigurowa\u0107. ",type:"long_open",correct_answer:`Konfigurowalne parametry statyczne ko\u0144c\xF3wek Spartan3E: 
- standard napi\u0119ciowy TTL/CMOS (kilka r\xF3\u017Cnych odmian) - okre\u015Bla poziomy napi\u0119\u0107 stan\xF3w wysokich i niskich dla kom\xF3rek wej\u015Bciowych jak i wyj\u015Bciowych. Trzeba na to zwraca\u0107 uwag\u0119 gdy\u017C nie wszystkie standardy mo\u017Cna \u0142\u0105czy\u0107 ze sob\u0105 (np. wyj\u015B\u0107 TTL z wej\u015Bciami niskonapi\u0119ciowymi CMOS). Z\u0142e dobranie standard\xF3w mo\u017Ce spowodowa\u0107 uszkodzenie uk\u0142ad\xF3w albo problem z identyfikacji stanu logicznego (gdy np. poziom stanu jednego standardu trafia akurat w zakres napi\u0119\u0107 nieustalonych drugiego standardu). 
- programowalny max pr\u0105d wyj\u015Bciowy 
- programowalny pull-up/pull-down okre\u015Bla do jakiego potencja\u0142u ma by\u0107 do\u0142\u0105czony pin wej\u015Bciowy. 
- \u201Eclamping\u201D - do pad'u mog\u0105 by\u0107 do\u0142\u0105czone diody stanowi\u0105ce zabezpieczaj\u0105cy ogranicznik napi\u0119cia (3.3V), stosowane do aplikacji PCI. W\u0142\u0105czenie tych diod i po\u0142\u0105czenie uk\u0142adu do jakiego\u015B wyj\u015Bcia TTL (+5V) mo\u017Ce spowodowa\u0107 przep\u0142yw znacznego pr\u0105du przez diody i uszkodzi\u0107 uk\u0142ad. Diody te s\u0105 domy\u015Blnie wy\u0142\u0105czone. 
To w starym opracowaniu (poni\u017Cej) jest \u017Ale! (skonsultowane z Mironem) Parametry: 
- FF/Latch (przerzutnik/zatrzask), 
- SYNC/ASYNC (sygna\u0142 set-reset asynchroniczny albo synchroniczny), - SRHIGH/SRLOW (sygna\u0142 set-reset czu\u0142y na wysoki/niski sygna\u0142), 
- INIT1/INIT0 (inicjalizacja przerzutnika po konfiguracji na \u20181\u2019 albo \u20180\u2019)`,scale:10},{question:"Wymie\u0144 tryby konfiguracji uk\u0142adu Spartan3E. ",type:"long_open",correct_answer:`Tryby: 
- Master Serial, 
- SPI, 
- BPI, 
- Slave Parallel, 
- Slave serial, 
- JTAG`,scale:10},{question:"Opisz w\u0142a\u015Bciwo\u015Bci i zastosowanie bloku \u201Eweak-keeper\u201D w uk\u0142adzie Spartan3E.",type:"long_open",correct_answer:`W\u0142a\u015Bciwo\u015Bci i zastosowanie: 
Kr\xF3cej* - weak-keeper utrzymuje stan magistrali na ostatnim stanie u\u017Cytecznym. Stosuje si\u0119 go w celu zapobiegania zjawisku fluktuacji napi\u0119cia. Zjawisko to jest bardzo niekorzystne z racji na ci\u0105g\u0142\u0105 obserwacj\u0119 tego napi\u0119cia przez bufory wej\u015Bciowe i kiedy wyst\u0119puj\u0105 po\u015Brednie napi\u0119cia (na granicy fizycznej realizacji \u20180\u2019 i \u20181\u2019) zwi\u0119ksza si\u0119 przep\u0142yw pr\u0105du i ro\u015Bnie pob\xF3r mocy. 
*D\u0142u\u017Cej weak-keeper (bus-keeper latch) - jest rodzajem s\u0142abego zatrzasku, kt\xF3ry dzia\u0142a jak inteligentny pull-up i pull-down jednocze\u015Bnie, je\u017Celi ostatnio wystawiono \u20180\u2019 to weak-keeper b\u0119dzie si\u0119 zachowywa\u0142 jak pulldown, a je\u017Celi \u20181\u2019 to pull up. Ma zastosowanie, kiedy z r\xF3wnym prawdopodobie\u0144stwem na magistral\u0119 wystawiamy oba sygna\u0142y.`,scale:10},{question:"Wyja\u015Bnij poj\u0119cie \u201Elocal routing\u201D. ",type:"long_open",correct_answer:`Poj\u0119cie oznacza po\u0142\u0105czenia w architekturze FPGA, pomi\u0119dzy s\u0105siednimi kom\xF3rkami, bez wykorzystania uniwersalnego uk\u0142adu \u0142\u0105cz\u0105cego. S\u0105siednie (czasem tak\u017Ce na skos) kom\xF3rki widz\u0105 si\u0119 jakby bezpo\u015Brednio. Jest to tak\u017Ce
technika po\u0142\u0105cze\u0144 wewn\u0105trz kom\xF3rki - z wykorzystaniem multiplekser\xF3w ( dzi\u0119ki temu szybkie wewn\u0119trzne po\u0142\u0105czenia)`,scale:10},{question:"poj\u0119cie \u201Egeneral purpose routing\u201D. ",type:"long_open",correct_answer:`Poj\u0119cie oznacza uniwersalne po\u0142\u0105czenia w architekturze FPGA, umo\u017Cliwiaj\u0105ce sygna\u0142owi dotarcie do ka\u017Cdej kom\xF3rki uk\u0142adu. Mo\u017Cna taki routing podzieli\u0107 na kilka warstw: 
- o kr\xF3tkim dystansie - od 2 do kilku blok\xF3w 
- o \u015Brednim dystansie - kilka - kilkana\u015Bcie 
- na ca\u0142y uk\u0142ad scalony - np. linia pionowa/pozioma przez ca\u0142y uk\u0142ad`,scale:10},{question:"poj\u0119cie \u201Eglobal routing\u201D. ",type:"long_open",correct_answer:"Poj\u0119cie oznacza po\u0142\u0105czenia w architekturze FPGA, dla sygna\u0142\xF3w, kt\xF3re musz\u0105 by\u0107 rozprowadzone po ca\u0142ym systemie m. in. sygna\u0142y zegara, resetu, trzeciego stanu logicznego I/O. Takie po\u0142\u0105czenie musi zapewni\u0107 odpowiednie w\u0142asno\u015Bci sygna\u0142\xF3w, na przyk\u0142ad dla zegara ma\u0142y skos - do wszystkich blok\xF3w sygna\u0142 dociera w tym samym czasie.",scale:10},{question:"poj\u0119cie \u201Ededicated routing\u201D. ",type:"long_open",correct_answer:"Poj\u0119cie oznacza po\u0142\u0105czenia w architekturze FPGA, dedykowane dla pewnej funkcjonalno\u015Bci np. budowy sumator\xF3w - sygna\u0142 carry musi by\u0107 bardzo szybko przekazany do nast\u0119pnego bloku - realizuje si\u0119 takie po\u0142\u0105czenie w spos\xF3b bezpo\u015Bredni mi\u0119dzy blokami sumatora - nie ma tam \u017Cadnych kluczy.",scale:10},{question:"poj\u0119cie \u201Eclock skew\u201D oraz podaj sposoby jego zmniejszania lub kompensacji. ",type:"long_open",correct_answer:"Clock skew wyst\u0119puje kiedy z jednego \u017Ar\xF3d\u0142a sygna\u0142u zegarowego, sygna\u0142 dociera do r\xF3\u017Cnych blok\xF3w/komponent\xF3w w r\xF3\u017Cnym czasie (\u017Ar\xF3d\u0142o). Kompensacj\u0119 tego zjawiska mo\u017Cna uzyska\u0107 wykorzystuj\u0105c drzewo dystrybucji sygna\u0142u zegarowego wewn\u0105trz chipu, kt\xF3re zajmuje si\u0119 dystrybucj\u0105 zegara o okre\u015Blonej fazie do przerzutnik\xF3w stosuj\u0105c odpowiednie op\xF3\u017Anienia. Wykorzystuje si\u0119 tak\u017Ce uk\u0142ad Clock Managera, kt\xF3ry sprawia, \u017Ce sygna\u0142 wej\u015Bciowy jest zgodny z faz\u0105 sygna\u0142u dystrybuowanego przez drzewo opisane powy\u017Cej.",scale:10},{question:"poj\u0119cie Delay Locked Loop, narysuj schemat takiej p\u0119tli i podaj zastosowania. ",type:"long_open",correct_answer:`Jest to p\u0119tla, kt\xF3ra d\u0105\u017Cy do tego, aby op\xF3\u017Anienie sygna\u0142u w bloku kwadratowym na rysunku poni\u017Cej by\u0142o takie, aby r\xF3\u017Cnica w fazie wchodz\u0105cych sygna\u0142\xF3w by\u0142a r\xF3wna 0ns. DLL Jest stosowana np. w uk\u0142adach FPGA w Device Clock Managerze, w celu zapewnienia, \u017Ce sygna\u0142 zegarowy
w sieci dystrybucji b\u0119dzie mia\u0142 dok\u0142adnie tak\u0105 faz\u0119 jak sygna\u0142 zegarowy na pinie wej\u015Bciowym.`,scale:10},{question:"sygna\u0142y generuje uk\u0142ad DCM w uk\u0142adzie Spartan3E. Jakie s\u0105 wymagania odno\u015Bnie parametr\xF3w sygna\u0142u zegarowego. ",type:"long_open",correct_answer:`Sygna\u0142y przesuni\u0119te w fazie o odpowiednio 0, 90, 180, 270 stopni, ewentualnie pomno\u017Cone/podzielone przez 2 albo programowaln\u0105 warto\u015B\u0107: - CLK0, CLK90, CLK180, CLK270 
- CLK2X, CLK2X180 
- CLKFX, CLKFX180 
- CLKDV 
Informacja czy nast\u0105pi\u0142a synchronizacja w p\u0119tli DLL: 
- LOCKED 
G\u0142\xF3wne wymagania odno\u015Bnie parametr\xF3w wyj\u015Bciowego sygna\u0142u zegarowego wzgl\u0119dem wej\u015Bciowego to: 
- r\xF3wny wsp\xF3\u0142czynnik wype\u0142nienia sygna\u0142u zegarowego (czas trwania '1' i '0' wynosi po 50% cyklu), 
- redukcja skosu zegara/synchronizacja faz sygna\u0142\xF3w/(minimalizacja r\xF3\u017Cnicy w fazie sygna\u0142\xF3w), 
- dost\u0119p (osobne sygna\u0142y) do przesuni\u0119cia zegara w fazie, 
- dost\u0119p (osobne sygna\u0142y) do zsyntezowanego sygna\u0142u zegarowego o cz\u0119stotliwo\u015Bci zgodnej z zaprogramowanymi warto\u015Bciami dzielnika i mno\u017Cnika.`,scale:10},{question:"i scharakteryzuj tryby zapisu jednoportowych pami\u0119ci Block-RAM w uk\u0142adach Spartan3E. ",type:"long_open",correct_answer:`Trzy tryby zapisu - w ka\u017Cdym warto\u015B\u0107 zostaje zapisana do pami\u0119ci: 
    a. WRITE_FIRST - opr\xF3cz zapisu, w tym samym cyklu zegarowym, obecna warto\u015B\u0107 zostaje przekierowana na wyj\u015Bcie, 
    b. READ_FIRST - opr\xF3cz zapisu, poprzednia zawarto\u015B\u0107 pami\u0119ci zostaje wystawiona na wyj\u015Bcie, 
    c. NO_CHANGE - opr\xF3cz zapisu, nic wi\u0119cej.`,scale:10},{question:"mo\u017Cliwe zastosowania jednoportowych pami\u0119ci Block-RAM w uk\u0142adach Spartan3E.",type:"long_open",correct_answer:`Zastosowania: 
- Du\u017Ce pami\u0119ci synchroniczne SRAM jednoportowe z mo\u017Cliwo\u015Bci\u0105 inicjacji zawarto\u015Bci podczas konfiguracji, 
- Du\u017Ce pami\u0119ci ROM, 
- Synchroniczne i asynchroniczne FIFO, 
- Pami\u0119\u0107 typu LIFO (stos) do procesor\xF3w, 
- Szybka implementacja z\u0142o\u017Conych funkcji logicznych, 
- Rejestry przesuwne, 
- Z\u0142o\u017Cone maszyny stan\xF3w, 
- Szybkie liczniki, 
- Bufory cyrkulacyjne, 
- Linie op\xF3\u017Aniaj\u0105ce (np. do FIR).`,scale:10},{question:"w\u0142a\u015Bciwo\u015Bci i zastosowania 2-portowych pami\u0119ci Block-RAM w uk\u0142adach Spartan3E. ",type:"long_open",correct_answer:`W\u0142a\u015Bciwo\u015Bci: 
- mo\u017Cliwe jednoczesny(e) zapis(y)/odczyt(y) w tym samym czasie (cyklu zegara) - wsp\xF3\u0142bie\u017Cny wielodost\u0119p 
- Z powodu jednoczesnego dost\u0119pu mog\u0105 wyst\u0105pi\u0107 kolizje, - ka\u017Cdy z port\xF3w posiada osobny zegar - mo\u017Ce wi\u0119c pe\u0142ni\u0107 rol\u0119 interfejsu do pami\u0119ci RAM z r\xF3\u017Cnych domen zegarowych (uk\u0142ad\xF3w taktowanych zegarami o r\xF3\u017Cnych cz\u0119stotliwo\u015Bciach). 
Zastosowania: 
- Du\u017Ce pami\u0119ci synchroniczne SRAM dwuportowe z mo\u017Cliwo\u015Bci\u0105 inicjacji zawarto\u015Bci podczas konfiguracji, 
- Du\u017Ce pami\u0119ci ROM, 
- Synchroniczne i asynchroniczne FIFO, 
- Pami\u0119\u0107 typu LIFO (stos) do procesor\xF3w, 
- Szybka implementacja z\u0142o\u017Conych funkcji logicznych, 
- Rejestry przesuwne, 
- Z\u0142o\u017Cone maszyny stan\xF3w, 
- Szybkie liczniki, 
- Bufory cyrkulacyjne, 
- Linie op\xF3\u017Aniaj\u0105ce (np. do FIR).`,scale:10},{question:"funkcje kt\xF3re mo\u017Ce w kom\xF3rce CLB uk\u0142adu Spartan3E spe\u0142nia\u0107 blok LUT. ",type:"long_open",correct_answer:`Funkcje LUT w CLB: 
- uk\u0142ad logiczny z nawet 9 wej\u015Bciami, 
- jednoportowy blok pami\u0119ci RAM adresowany 4 bitami 
- dynamiczny 16-bitowy rejestr przesuwny z szeregowym I/O, bez resetu - tylko z zegarem,
mo\u017Cna o tym wspomnie\u0107, ale nie jest to odpowied\u017A na pytanie: - cz\u0119\u015Bciowo-dual (tylko odczyt) blok pami\u0119ci RAM adresowany 4 bitami w przypadku po\u0142\u0105czenia dw\xF3ch blok\xF3w LUT, 
- jednoportowy blok pami\u0119ci RAM adresowany 5 bitami w przypadku po\u0142\u0105czenia dw\xF3ch blok\xF3w LUT za pomoc\u0105 F5MUX),`,scale:10},{question:"r\xF3\u017Cnice w budowie uk\u0142ad\xF3w PLA i PAL. ",type:"long_open",correct_answer:"W uk\u0142adach PLA (Programmable Logic Array) wyst\u0119puj\u0105 2 matryce programowalne - matryca AND do tworzenia minterm\xF3w i matryca OR do ich sumowania. Z racji na programowalno\u015B\u0107 obu matryc i wynikaj\u0105ce z tego op\xF3\u017Anienia powsta\u0142y uk\u0142ady PAL (Programmable Array Logic). W tych uk\u0142adach programowalna jest jedynie matryca AND, to ta do tworzenia minterm\xF3w, natomiast w matrycy OR po\u0142\u0105czenia s\u0105 przypisane na sta\u0142e - pozwoli\u0142o to zmniejszy\u0107 op\xF3\u017Anienia.",scale:10},{question:"i kr\xF3tko scharakteryzuj poziomy abstrakcji stosowane w opisie sprz\u0119tu. ",type:"long_open",correct_answer:`Poziomy od najwi\u0119kszego poziomu abstrakcji: 
a. System - behawioralnie opisywany w j\u0119zyku naturalnym - strukturalnie np. jednostka centralna, 
b. Uk\u0142ad scalony - behawioralnie zestaw algorytm\xF3w - strukturalnie np. mikroprocesor, 
c. Rejestry - behawioralnie przep\u0142yw danych - strukturalnie np. rejestry d. Bramki - behawioralnie r\xF3wnania logiczne - strukturalnie funktory logiczne: and, or, xor, 
e. Uk\u0142ad elektr. - behawioralnie r\xF3wnania r\xF3\u017Cniczkowe - strukturalnie np. tranzystory, 
f. Layout, krzem - behawioralnie fizyka p\xF3\u0142przewodnik\xF3w - strukturalnie geometria struktur`,scale:10},{question:"metody opisu uk\u0142ad\xF3w cyfrowych. ",type:"long_open",correct_answer:`Metody opisu uk\u0142ad\xF3w blokowych: 
- Schemat ideowy, 
- Schemat blokowy, 
- Diagram czasowy, 
- Graf maszyny stan\xF3w, 
- Tabela prawdy, 
- R\xF3wnania logiczne.`,scale:10},{question:"to jest podzbi\xF3r syntezowalny j\u0119zyka VHDL, podaj przyk\u0142ad instrukcji niesyntezowalnej.",type:"long_open",correct_answer:`J\u0119zyk VHDL jest stosowany w 2 g\u0142\xF3wnych celach: syntezy rozwi\u0105za\u0144 dla uk\u0142ad\xF3w elektronicznych oraz symulacji tych uk\u0142ad\xF3w. Cz\u0119\u015B\u0107 konstrukcji j\u0119zyka wykorzystywana jest wy\u0142\u0105cznie w przypadku symulacji i nie istnieje 
mo\u017Cliwo\u015B\u0107 skompilowania ich do programu wykonywalnego na p\u0142ytce. Takie konstrukcje nazywamy niesyntezowalnymi, a przyk\u0142adem jest instrukcja \u201Cwait for\u201D. Podzbi\xF3r syntezowalny jest wi\u0119c zbiorem (okre\u015Blonym standardem IEEE) takich instrukcji, kt\xF3re mog\u0105 zosta\u0107 skompilowane do programu wykonywalnego na fizycznym uk\u0142adzie (np. FPGA). 
\u017Ar\xF3d\u0142o`,scale:10},{question:"to jest funkcja rezolucji. ",type:"long_open",correct_answer:`Funkcja rezolucji okre\u015Bla jaka powinna by\u0107 warto\u015B\u0107 sygna\u0142u, do kt\xF3rego wsp\xF3\u0142bie\u017Cnie przypisujemy wi\u0119cej ni\u017C jedn\u0105 warto\u015B\u0107 np.: signal_1 <= signal_2; 
signal_1 <= signal_3; 
Funkcja rezolucji pozwala na rozwi\u0105zanie niesyntezowalno\u015Bci takiego przypisania oraz na syntez\u0119 logiki tr\xF3jstanowej wewn\u0105trz uk\u0142adu.`,scale:10},{question:"sposoby unikania stan\xF3w zabronionych w maszynach stan\xF3w. W systemach \u201Emission-critical\u201D mo\u017Cna w\u0142\u0105czy\u0107 odpowiedni\u0105 opcj\u0119 syntezera (je\u017Celi jest dost\u0119pna) generuj\u0105c\u0105 maszyny stan\xF3w zabezpieczone przed zatrza\u015Bni\u0119ciem si\u0119 w stanie niedozwolonym. ",type:"long_open",correct_answer:`W przypadku braku opcji w syntezerze: 
- U\u017Cy\u0107 maszyny stan\xF3w z bezpo\u015Brednim kodowaniem stan\xF3w i okre\u015Bli\u0107 w\u0142a\u015Bciwe zachowanie si\u0119 maszyny dla wszystkich, tak\u017Ce nieu\u017Cywanych stan\xF3w. 
- Doda\u0107 uk\u0142ad logiczny wykrywaj\u0105cy stan niedozwolony. 
Ponadto aby unikn\u0105\u0107 problem\xF3w zwi\u0105zanych z asynchronicznym wej\u015Bciem nale\u017Cy przes\u0142a\u0107 sygna\u0142 asynchroniczny przez co najmniej jeden przerzutnik typu D.`,scale:10},{question:"to jest metastabilno\u015B\u0107 przerzutnik\xF3w. ",type:"long_open",correct_answer:"Zjawisko to polega na pozostawaniu przerzutnika przez pewien czas w r\xF3wnowadze chwiejnej pomi\u0119dzy dwoma stanami stabilnymi.",scale:10},{question:"i kr\xF3tko scharakteryzuj trzy sposoby syntezy z wykorzystaniem blok\xF3w funkcjonalnych w uk\u0142adach FPGA. ",type:"long_open",correct_answer:`    a. Primitives - w syntezie automatycznie rozpoznawane s\u0105 typowe bloki funkcjonalne i stosowane s\u0105 znane przepisy na ich realizacj\u0119
    b. Inferred macros - w syntezie rozpoznawane s\u0105 w kodzie VHDL odpowiednio opisane komponenty (makra) jako bloki funkcjonalne i wykorzystywane s\u0105 gotowe schematy takich blok\xF3w dla uk\u0142adu. Rozpoznawanie wymaga jednak od tw\xF3rcy kodu \u015Bwiadomo\u015Bci istnienia takich blok\xF3w i stworzenie kodu w VHDL zgodnie z ich konstrukcj\u0105. 
    c. Instantiated macros - Jawnie wykorzystujemy blok funkcjonalny okre\u015Blaj\u0105c rodzaj modu\u0142u, jego konfiguracj\u0119, oraz po\u0142\u0105czenia z sygna\u0142ami.`,scale:10},{question:"w\u0142a\u015Bciwo\u015Bci zmiennych w procesach. ",type:"long_open",correct_answer:`- s\u0105 widoczne tylko w obr\u0119bie procesu dla kt\xF3rego s\u0105 zdefiniowane, - zachowuj\u0105 swoj\u0105 warto\u015B\u0107 w czasie kiedy proces nie jest u\u017Cywany (kiedy sygna\u0142y z listy czu\u0142o\u015Bci nie zmieniaj\u0105 swojego stanu), 
- ich zmiana nast\u0119puje natychmiast po napotkaniu przypisania zmiennej := w trakcie sekwencyjnego dzia\u0142ania procesu, 
- do zmiennej mo\u017Cna przypisa\u0107 warto\u015B\u0107 pocz\u0105tkow\u0105, kt\xF3ra zostanie przypisana tylko raz (na pocz\u0105tku syntezy).`,scale:10},{question:"w\u0142a\u015Bciwo\u015Bci zmiennych w funkcjach. ",type:"long_open",correct_answer:`- s\u0105 widoczne tylko w obr\u0119bie funkcji dla kt\xF3rego s\u0105 zdefiniowane, - ich zmiana nast\u0119puje natychmiast po napotkaniu przypisania zmiennej := w trakcie sekwencyjnego dzia\u0142ania procesu, 
- do zmiennej mo\u017Cna przypisa\u0107 warto\u015B\u0107 pocz\u0105tkow\u0105, kt\xF3ra zostanie przypisana przy ka\u017Cdym wywo\u0142aniu funkcji, 
- nie zachowuj\u0105 swojej warto\u015Bci w czasie kiedy funkcja nie jest u\u017Cywana - przy wywo\u0142aniu funkcji ustawiane s\u0105 warto\u015Bci pocz\u0105tkowe.`,scale:10},{question:"zasadnicze r\xF3\u017Cnice pomi\u0119dzy zmiennymi a sygna\u0142ami.  ",type:"long_open",correct_answer:`- przypisanie warto\u015Bci do zmiennych jest natychmiastowe i w rezultacie sekwencyjne, natomiast do sygna\u0142\xF3w odbywa si\u0119 synchronicznie (np. pod koniec procesu) i w rezultacie wsp\xF3\u0142bie\u017Cnie. 
- w procesach zmienne zachowuj\u0105 swoj\u0105 warto\u015B\u0107 kiedy proces nie jest u\u017Cywany, 
- sygna\u0142y s\u0142u\u017C\u0105 do obs\u0142ugi wej\u015Bcia i wyj\u015Bcia uk\u0142adu, 
- sygna\u0142y skojarzone s\u0105 bardziej z fizycznym sprz\u0119tem, natomiast zmienne z abstrakcyjnym przetwarzaniem danych.`,scale:10},{question:"sposoby parametryzacji modu\u0142\xF3w projektowych. ",type:"long_open",correct_answer:`a. niejawny - parametr podany jest do modu\u0142u nie wprost - np. u\u017Cywamy typu tablicowego unconstrained w kt\xF3rym parametrem b\u0119dzie d\u0142ugo\u015B\u0107 podanej na wej\u015Bcie tablicy 
b. jawny - parametry, przekazywane do modu\u0142u podobnie jak sygna\u0142y, s\u0105 tylko wej\u015Bciem do modu\u0142u i definiujemy je w osobnym bloku generic. Parametry mog\u0105 mie\u0107 typy takie jak sygna\u0142y, ale musz\u0105 mie\u0107 sta\u0142\u0105 warto\u015B\u0107 (np. domy\u015Bln\u0105).`,scale:10},{question:"to jest \u201Eunconstrained vector\u201D, podaj zastosowania. ",type:"long_open",correct_answer:"Unconstrained vector jest typem tablicowym, parametr funkcji takiego typu mo\u017Ce by\u0107 dowolnej d\u0142ugo\u015Bci. Taki mechanizm umo\u017Cliwia budowanie uniwersalnych funkcji operuj\u0105cych na tablicach r\xF3\u017Cnych d\u0142ugo\u015Bci. W momencie syntezy d\u0142ugo\u015B\u0107 b\u0119dzie znana i mo\u017Cliwe b\u0119dzie wykonanie funkcji dla tablicy o konkretnej d\u0142ugo\u015Bci.",scale:10},{question:"to s\u0105 cykle delta, podaj przyk\u0142ad. ",type:"long_open",correct_answer:`Cykle delta, s\u0105 to dodatkowe logiczne cykle (w czasie jednego cyklu fizycznego), kt\xF3re s\u0142u\u017C\u0105 do oblicze\u0144 po\u015Brednich warto\u015Bci sygna\u0142\xF3w, w przypadku w kt\xF3rym zmieniamy wewn\u0105trz procedury sygna\u0142 b\u0119d\u0105cy na li\u015Bcie czu\u0142o\u015Bci. 
Zak\u0142adaj\u0105c, \u017Ce zmianie ulegnie sygna\u0142 a, po wykryciu tej zmiany w zwyk\u0142ym cyklu ulegnie zmianie sygna\u0142 x, co spowoduje wykonanie cyklu delta, w kt\xF3rym proces aktywuje si\u0119 ponownie i przypiszemy sygna\u0142 x do sygna\u0142u y.`,scale:10},{question:"musi by\u0107 liczba iteracji syntezowalnej p\u0119tli ?",type:"long_open",correct_answer:"Syntezowalna p\u0119tla musi mie\u0107 ograniczon\u0105 liczb\u0119 iteracji (znan\u0105/sta\u0142\u0105 w momencie syntezy).",scale:10},{question:"czego s\u0142u\u017Cy instrukcja \u201Egenerate\u201D ?",type:"long_open",correct_answer:"Instrukcja s\u0142u\u017Cy do automatycznego pod\u0142\u0105czenia komponent\xF3w. W opisie bardziej formalnym oznacza to, \u017Ce s\u0142u\u017Cy do automatycznej generacji struktur regularnych, tworzonych na bazie struktury wzorcowej (fizyczny efekt to powielenie poduk\u0142ad\xF3w wzorcowych)",scale:10}];var o={name:a,quiz_elements:e};export{o as default,a as name,e as quiz_elements};
