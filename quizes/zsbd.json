{
    "name": "ZSBD (KIO): Zarządzanie Systemami Baz Danych",
    "quiz_elements": [
{
    "question": "W1: Jaka jest różnica pomiędzy instancją Oracle, bazą danych Oracle a serwerem Oracle?",
    "type": "long_open",
    "correct_answer": "Instancja - jest to tak naprawdę dana instalacja Serwera Oraclowego, można mieć dostęp do tylko jednej instancji na raz, jest to zbiór procesów działających w tle i struktur pamięci, które umożliwiają zarządzanie bazą danych. Instacja nie potrzebuje posiadać Bazy Danych aby mogła pracować. Do danej instancji może być podpiętych wiele baz danych oraclowych.\nBaza Danych - zbiór fizycznych struktur składowania wszystkich danych użytkownika i innych danych bazy danych. \nSerwer - na serwer oracle składa się: Instancja Oracle, Baza Danych Oracle (od 19c może być ich wiele (pluggable i kontenerowe), ale zawsze możemy być podłączeni tylko do jednej), pliki dodatkowe  (np. pliki archiwów, plik do autoryzacji użytkowników specjalnych), procesy serwera służace dostępowi do instancji, proces listenera oczekujący na nowe żądania dostępu.",
    "scale": 1
},
{
    "question": "W1: Jaka jest różnica między trybami działania bazy: dedykowanym a współdzielonym?",
    "type": "long_open",
    "correct_answer": "Dedykowany tryb - dla każdego użytkownika tworzony jest osobny proces serwera, któremu przypisywane jest PGA (Program Global Area - fragment pamięci dedykowany tylko dla procesu serwera). Dla wielu konkurentych użytkowników, rozwiązanie to bywa bardzo obciążające dla zasobów serwera. Tryb ten jest idealny dla: administrowania bazy danych, przeprowadzanie backupów i recovery, batch processing i bulk load operations, Hurtowni Danych.\n\n Współdzielony tryb - po starcie instancji tworzona jest określona ilość procesów serwera (mogą zostać potem dodane jeśli potrzeba). Współdzielony tryb dodatkowo składa się z procesów dispatchera, który może odpowiadać za zarządzanie sesji wielu użytkowników. Użytkownik jest podłączony do tego samego dispatchera podczas czasu trwania sesji. W współdzielonym trybie serwera, żądania użytkownika są zawsze przekazywane do procesu serwera, który jest najmniej obciążony.",
    "scale": 1
},
{
    "question": "W1: Jakie są procesy instancji Oracle?",
    "type": "long_open",
    "correct_answer": "Mandatory:\nPMON (process monitor process) - monitoruje wszystkie procesy, sprawdza czy któryś z nich się nie zawiesił / nie działa, czy nie trzeba go zrestartować, czyści database buffer cache i zwalnia zasoby.\n\nSMON (system monitor process) - sprawdza czy dane w bazie danych są spójne, odpowiada za consistency. Będzie inicjować odtworzenie instacji w momencie gdy dojdzie do np. chwilowego zaniku prądu, uszkodzenia dysku, po restarcie instancji SMON sprawdza czy dane na których był commit zostały faktycznie wprowadzone, jeżeli baza jest w stanie niespójnym, następuje recovery.\n\nDBWn (database writer process) - zapisuje bloki danych zawarte w buforze danych, do plików danych, co jakiś czas albo podczas checkpointu.\n\nLGWR (log writer process) - serwisuje bloki dziennika powtórzeń z bufora do plików, w formie commita. Jeśli log file jest pełny inicjalizuje checkpoint.\n\nCKPT (checkpoint process) - proces który aktualizuje plik kontrolny i nagłowki plików danych z informacją o checkpointach, w momencie checkpointu inicjalizuje DBWn aby zapisał bloki danych na dysk.\n\nMMON (manageability monitor process) - mechanizm, który wykonuje zadania związane z AWR. AWR (automatic workload repository) - w sposób automatyczny monitoruje stan bazy, obciążenie bazy na podstawie np. ustawionych alertów, tresholdów. Automatycznie raportuje w narzędziu administracyjnym jeśli metryki zostaną przekroczone.\n\nMMNL (manageability monitor lite process) - zapisuje statystyki z bufora ASH (active session history) w SGA na dysk.\n\nAdditional:\nRECO (recoverer process)  - w momencie gdy SMON stwierdzi, że stan bazy jest niespójny po jej uruchomieniu, RECO automatycznie naprawia błędy w dystrubuowanych transakcjach.\nARCn - archiver process(es) - copy online redo log files to offline storage after a redo log switch occurs; collect transaction redo data and transmit it to standby database destinations; ARCn processes exist only when the database is in ARCHIVELOG mode",
    "scale": 1
},
{
    "question": "W1: Jakie bufory wchodzą w skład instancji Oracle?",
    "type": "long_open",
    "correct_answer": "Buffer Cache - bufor danych - przechowuje bloki bazodanowe, które są czytane z plików danych, stosując mechanizm LRU (least recently used) (ostatnio używane bloki znajdują się w pamięci). Stosujemy go, ponieważ jeżeli wielu użytkowników będzie korzystało z dokładnie z tych samych danych, to nie musimy odczytywać ich z pliku tylko z tego bufora. Dla hurtowni danych nie jest on tak potrzebny ale dla transakcyjnych baz danych warto ustawić jego wartość na tyle dużą aby te wspólnie używane bloki mieściły się w tym buforze.\nRedo Log Buffer - dziennik powtórzeń - służy on do tego aby przechowywać dane potrzebne do wycofania transakcji, albo do zrobienia redo na zmianach do bazy danych. Zawiera on pliki dziennika powtórzeń, czyli kolejne wpisy zawierające informacje o tym jakie zmiany zostały zrobione na bazie danych (poprzednia wartość -> aktualna wartość). Commit wymusza zapisanie danych z tego bufora do plików dziennika powtórzeń, przy checkpoincie pliki dziennika powtórzeń zapisywane są do plików danych.\n\n\nShared pool - bufor współdzielony, zawiera dane współdzielone między wielu użytkowników:\nLibrary Cache - zawiera skompilowane plany wykonania zapytań, służy do przyspieszenia czasu wykonywania powtarzających się zapytań, jeśli dane zapytanie posiada już swój plan w tym cachu to sprawdzane są tylko uprawnienia i od razu zapytanie jest wykonywane. Jeden z najważniejszych buforów, od jego rozmiaru zależy szybkość wykonywania poleceń.\nData Dictionary Cache - cache przechowujący słownik, powinien być na tyle duży aby słownik się w nim zmieścił, aby nie trzeba było czytać z pliku danych. \nData Dictionary Cache - holds information about database objects; data dictionary is a collection of database tables and views containing reference information about the database, its structures, and its users; <- to jest z prezki\nSQL Query Result Cache - nie zawiera bloków danych, ale rezultaty zapytań.\nPl/SQL Function Result Cache - zawiera rezultaty wykonanych funkcji PL/SQL\nLarge Pool - alokowany jeśli posługujemy się Large Objects.\nJava Pool - służy do składowania procedur Java.",
    "scale": 1
},
{
    "question": "W1: Jaka jest różnica między PGA i SGA?",
    "type": "long_open",
    "correct_answer": "SGA (System Global Area) - obszar pamięci zaalokowany dla instancji, znajdują się w nim bufory opisane w pytaniu 4.\n\nPGA (Program Global Area) - znajdują się w nim procesy serwera, które są poza instancją, pośredniczą one w dostępie do instancji, mają własne bufory.",
    "scale": 1
},
{
    "question": "W1: Na czym polega tryb NOARCHIVELOG?",
    "type": "long_open",
    "correct_answer": "ARCHIVELOG - archiwizowanie plików dziennika powtórzeń przed nadpisaniem ich. Produkcyjne bazy danych muszą pracować w tym trybie\nNOARCHIVELOG - archiwizowanie plików dziennika powtórzeń nie występuje przed nadpisaniem ich. Czasami używany w hurtowniach danych.",
    "scale": 1
},
{
    "question": "W1: Wymień rodzaje plików bazy danych Oracle.",
    "type": "long_open",
    "correct_answer": "Pliki danych - zawierają bloki danych, słownik, dane użytkowników, uprawnienia.\nPlik kontrolny - początkowo tylko jeden, ale POWINIEN być multiplikowany , jeśli plik kontrolny się uszkodzi to nie ma możliwości dostępu do danych. Jest to kluczowy plik w dostępu do danych. Powinien być powielany na różnych dyskach. Zawiera on informacje o statusie danej bazy, ostatnim checkpoincie, adresy do plików danych, adresy do plików dziennika powtórzeń. \nPliki dziennika powtórzeń - kolejne wpisy zawierające informacje o tym jakie zmiany zostały zrobione na bazie danych (poprzednia wartość -> aktualna wartość). Commit wymusza zapisanie danych z tego bufora do plików dziennika powtórzeń, przy checkpoincie pliki dziennika powtórzeń zapisywane są do plików danych.",
    "scale": 1
},
{
    "question": "W2: Dlaczego należy wykonywać raport z instalacji SZBD Oracle?",
    "type": "long_open",
    "correct_answer": "Raport z instalacji Oracle zawiera wszystkie wybrane opcje, ścieżki, nazwy podczas instalacji instancji Oracle. Taki raport pomaga zindentyfikować gdzie coś poszło nie tak.",
    "scale": 1
},
{
    "question": "W2: Które domyślne ustawienia instalacji Oracle należy koniecznie zmienić?",
    "type": "long_open",
    "correct_answer": "w poprzednich wersjach oracle (w 19 automatycznie dezaktywowany), przy zdecydowaniu się na instalację domyślnych schematów należy zdezaktywować użytkownika SCOTT/TIGER. (ponieważ ma dostęp do wszystkiego co mają publiczni użytkownicy, i możliwość backdooru)\nnależy ustawić inne hasło dla każdego konta administracyjnego\nnależy stworzyć więcej niż jedną przestrzeń tabel dla użytkowników\nnależy zmienić folder w którym zapisują się kopie pliku kontrolnego",
    "scale": 1
},
{
    "question": "W2: Na czym polega konfiguracja środowiska sieciowego Oracle?",
    "type": "long_open",
    "correct_answer": "Na uruchomieniu Oracle Net Configuration assistant, następnie wybieramy, co byśmy chcieli skonfigurować, w naszym przypadku było to Local naming, następnie wybranie typu akcji jaką chcemy wykonać (stworzyć, przetestować, usunąć, zrekonfigurować, zmienić nazwę), następnie wybieramy nazwę bazy danych, wybieramy protokół sieciowy (TCP, TCPS, IPC), następnie nazwa hosta i port, i następnie zdefiniowanie nazwy do połączenia się.",
    "scale": 1
},
{
    "question": "W2: Jak Oracle można dopasować do wspomagania bazy o charakterze transakcyjnym lub analitycznym (OLTP a OLAP)?",
    "type": "long_open",
    "correct_answer": "W wersji 19c posiadamy wybór między dwoma typami konfiguracji bazy: General purpose/Transactional Processing, a Data Wearhousing. Jeśli chcemy wspomagać bazę o charakterze analitycznym powinniśmy wybrać opcję Data Wearhousing, natomiast jeśli interesuje nas baza o charakterze transakcyjnym, lub nie jesteśmy jeszcze pewni przeznaczenia naszej bazy, powinniśmy wybrać opcję General purpose/Transactional Processing. Jeśli chcemy sami dobrać parametry, to 2 najważniejsze wyróżniające 2 powyższe charaktery baz to db_file_multiblock_read_count, który powinien być większy w przypadku analitycznej bazy, oraz Pga_aggregate_target, który również powinien być większy w przypadku analitycznej bazy, w przypadku analitycznej bazy warto ustawić jeszcze Star_transformation_enabled na TRUE.\nW wypadku baz transakcyjnych warto rozważyć dodanie większej ilość pamięci dla obszaru PGA, w wypadku baz analitycznych, warto rozważyć dodanie większej ilości pamięci dla obszaru SGA.",
    "scale": 1
},
{
    "question": "W2: Jakie są statusy pracy instancji i do czego służą?",
    "type": "long_open",
    "correct_answer": "SHUTDOWN - instancja nie działa, może zalogować się do niej tylko użytkownik SYS autoryzowany przez plik haseł (password file), możliwe jest również uzyskanie dostępu do instancji w trybie NOLOG, i wtedy wykonać operację startup. \nNOMOUNT - instancja jest zainicjowana, ale nie jest podłączona baza danych, nie są wczytane pliki kontrolne, w tym trybie można operować na plikach kontrolnych.\nMOUNT - w tym trybie pliki kontrolne są otwarte, a pliki danych jeszcze nie, dlatego  jesteśmy w stanie operować na plikach danych, ale nie możliwe jest już operowanie na plikach kontrolnych.\nOPEN - w tym trybie baza danych i danych są w pełni otwarte, dlatego użytkownicy mogą już z niej korzystać\nCLOSE - database closed and control files opened\n\nProces uruchamiania instancji: SHUTDOWN - NOMOUNT - MOUNT - OPEN;\nProces zamykania instancji: OPEN - CLOSE - NOMOUNT - SHUTDOWN;\n\nTypy operacji shutdown:\nSHUTDOWN NORMAL - zwykły shutdown który czeka aż wszyscy użytkownicy się rozłączą przed zamknięciem bazy, z powodu takiego warunku może dojść do sytuacji w której baza nie zostanie wyłączona, bo zawsze ktoś będzie podłączony\nSHUTDOWN TRANSACTIONAL - uniemożliwia otwarcie nowych transkacji, ale czeka na wszystkie bieżące transkacje aby się zamknęły, może dojść do sytuacji, że użytkownik zawiśnie podczas transakcji i jeśli tryb autocommit jest wyłączony to wszystko robione będzie w obrębie transakcji\nSHUTDOWN IMMEDIATE - odłącza wszystkich użytkowników, zamyka wszystkie zapytania, zmiany które nie są commited są rollbackowane\nSHUTDOWN ABORT - po prostu zamyka instancję, ignorując transakcje użytkowników, po tym sposobie wyłączenia może być konieczność wykonania recovery bazy danych\nNajczęściej wykonuje się IMMEDIATE, czasami można manualnie zabić procesy użytkowników :) ",
    "scale": 1
},
{
    "question": "W3: Do czego służy i jak się stosuje mechanizm profilów?",
    "type": "long_open",
    "correct_answer": "Profile - zestaw parametrów, które dotyczą użytkownika, każdy użytkownik musi mieć profil, jeśli nie podamy mu go przy tworzeniu, to zostanie przypisany domyślny. Profil ma swoją nazwę, domyślnie kontroluje politykę autoryzacji, może też kontrolować politykę dostępu do zasobów, przy nie zaleca się robienia tego (polityki dostępu do zasobów) przez profile tylko przez dedykowane narzędzie (Resource Manager, pakiet PL/SQL).",
    "scale": 1
},
{
    "question": "W3: Do czego służy i jak się stosuje mechanizm quota (w tym efekty obniżenia quoty)?",
    "type": "long_open",
    "correct_answer": "Określa do jakiego rozmiaru dane w schemacie użytkownika mogą urosnąć na danej przestrzeni tabel, a nie ile użytkownik może wstawić danych. Jeśli QUOTA zostanie zmniejszona w trakcie, nasze dane nie zostaną usunięte, ale nie będziemy mogli wstawiać danych dopóki nie zmniejszymy rozmiaru naszych danych do rozmiaru QUOTY. Domyślnie wynosi 0 - zabrania wstawienia czegokolwiek, jest 1 wyjątek - chyba że posiadamy uprawnienie UNLIMITED TABLESPACE.",
    "scale": 1
},
{
    "question": "W3: Do czego służą role, jak się je stosuje i jakie mają ograniczenia?",
    "type": "long_open",
    "correct_answer": "Role to są 'kubełki', tworząc role musimy ją tylko nazwać, będzie to rola domyślna. Rola nie domyślna to taka, która przyznaje uprawnienia dopiero gdy się ją aktywuje. Rola służy po to aby wielu podobnym użytkownikom nadawać łatwiej te same uprawnienia, usprawnia ona pracę administratora bazy, redukując pomyłki w wypadku wpisywania tych uprawnień osobno dla każdego użytkownika. Role nie zawierają się w schemacie, nazwa roli powinna być unikatowa - różna od nazwy każdej innej roli i nazw użytkowników. Usunięcie użytkownika który stworzył rolę nie usuwa roli, usunięcie użytkownika, który nadał nam uprawnienia, nie usuwa nam tych uprawnień. Uprawnień nadanych przez role nie możemy używać w poleceniach definiujących dane (widoki, skrypty PL/SQL) - muszą być dodane manualnie.\nRole to są takie kubełki, ponieważ w poleceniu GRANT możemy po prostu dać nazwę roli i będzie to działać jak nadanie komuś jakiegoś uprawnienia, dla tego można je traktować jako takie kubełki na uprawnienia.",
    "scale": 1
},
{
    "question": "W3: Wyjaśnij różnicę pomiędzy uprawnieniami systemowymi oraz uprawnieniami do obiektów.",
    "type": "long_open",
    "correct_answer": "Z tego co rozumiem to uprawnienie systemowe daje nam ogólne prawo do np. wykonywania operacji SELECT na tabelach, prawo do łączenia się z bazą, tworzenia tabel. Posiada podzbiór nazwany Administrative privileges. Jeśli ktoś posiada uprawnienie z opcją ADMIN to może je dawać i zabierać każdemu użytkownikowi. W przypadku GRANT ANY PRIVILEGE możemy nie tylko tą permisję ale też każdą inną u każdego użytkownika.\nUprawnienia do obiektów, w porównaniu do systemowych nie są globalne tylko odnoszą się do specyficznym schema obiekcie, np. możemy mieć prawo do tworzenia tabel z system privileges ale w danej przestrzeni tabel możemy go nie mieć i w takim wypadku nie możemy stworzyć tabeli. Właściciel ma pełne prawa do obiektu i może je nadawać dalej. Jeśli chcemy dodać klucz obcy z kogoś innego tabeli musimy również posiadać uprawnienie REFERENCE do tej tabeli.\nSynonimy - to chyba po prostu zamiennik dla nazwy tabeli, widoku, sekwencji itd itd.\nW synonimach publicznych nie musimy podawać schematu ?? nadanie uprawnienia do synonimu nadaje uprawnienie do obiektu.\n\nUprawnienia i widoki: jeśli chcemy stworzyć widok musimy mieć uprawnienie do tworzenia widoku ale również musimy mieć uprawnienie do select na danej tabeli. Aby dawać innym uprawnienia do stworzonego widoku, musimy posiadać również uprawnienia ustawione za pomocą GRANT do tabeli z której był dany widok stworzony.Dzięki widokom możemy zwiększać bezpieczeństwo po przez ograniczanie liczby danych jakie inni użytkownicy mogą widzieć.\nUprawnienia administracyjne: to są po prostu kolejne systemowe uprawnienia tylko w charakterze stricte administracyjnym. SYSOPER daje możliwość na startup, shutdown i zmiany trybów bazy. SYSDBA ma w sobie SYSOPER, ma wszystkie uprawnienia z WITH ADMIN OPTION. Użytkownicy mający SYSDBA, SYSOPER, SYSAMS, SYSBACKUP, SYSDG mają swoje hasła w pliku haseł. Pliki haseł można tworzyć za pomocą ORAPWD.",
    "scale": 1
},
{
    "question": "W3: Wyjaśnij jakie efekty może mieć odebranie uprawnienia i w jakich przypadkach te efekty mogą wystąpić (odebranie uprawnień systemowych, do obiektów, roli).",
    "type": "long_open",
    "correct_answer": "Najpierw napiszę o grantach:\nGrant systemowy:\nnadajemy je poleceniem GRANT,\nmożemy dodać przywilej, rolę, i przypisać ją do roli, użytkownika.\n\nGrant na obiekcie:\nAby nadać komuś uprawnienie, dany użytkownik musi:\nbyć właścicielem obiektu || posiadać GRANT ANY OBJECT PRIVILEGE || GRANT ANY PRIVILEGE, || mieć privilege z WITH GRANT OPTION note to GRANT ANY PRIVILEGE, z tą komendą działami w imieniu ownera obiektu, więc jeśli nadamy komuś uprawnienia do kogoś tabeli to będzie to widoczne że owner tabeli nadał temu komuś uprawnienia a nie my.\n\nTeraz o revokach:\nUprawnienia systemowe\naby zrevokować dany privilege albo rolę dany użytkownik musi mieć ją nadaną z WITH ADMIN OPTION, albo mieć GRANT ANY PRIVILEGE albo GRANT ANY ROLE możemy zabierać uprawnienia domyślnym rolą nie jesteśmy w stanie odebrać użytkownikowi SYS żadnych uprawnień.\nGRANT ANY OBJECT PRIVILEGE i GRANT ANY PRIVILEGE może usunąć tylko uprawnienia które nadał właściciel, ponieważ revokuje je w jego imieniu\nDla obiektów nie można zrevokować uprawnień z danej kolumny właścicielowi nie można odebrać uprawnień.\n\nTeraz do sedna pytania:\njak chcemy komuś odebrać prawo do update jakiejś tabeli to musimy najpierw dać revoke update, przez co jeśli były jakieś inne tabele do jakich mieliśmy przywileje to je tracimy, i potem trzeba dać znowu update i osobno każdą tabelę do której użytkownik miał uprawnienie jeśli odbieramy komuś uprawnienie kto nadał innym osobom uprawnienie, to wtedy te inne osoby również tracą to uprawnienie GRANT ANY OBJECT PRIVILEGE i GRANT ANY PRIVILEGE może usunąć tylko uprawnienia które nadał właściciel, ponieważ revokuje je w jego imieniu wszystkie składowane skrypty PL/SQL tracą wszystkie uprawnienia, wraz z użytkownikiem w wypadku revoku jeśli odbierzemy uprawnienie REFERENCE to nie zadziała jeśli nie używamy revoka kaskadowego, lub jeśli użytkownik skorzystał z tego uprawnienia, aby zadziałało należy użyć go kaskadowo i wtedy wszystkie obiekty które należały do danego użytkownika ograniczenia typu FOREIGN KEY zostaną automatycznie usunięte ze wszystkich tabel danego użytkownika",
    "scale": 1
},
{
    "question": "W3:Wyjaśnij na czym polega mechanizm audytu i po co się go stosuje",
    "type": "long_open",
    "correct_answer": "Po co audyt? Jeśli posiadamy bardzo czułe dane, wtedy jesteśmy w stanie pociągnąć odpowiedzialną osobę do odpowiedzialnośc, która nabroji w bazie. Służy do monitorowania podejrzanych zachowań, sprawdzania aktywności bazy danych lub do wykrycia problemów z ustawieniami bezpieczeństwa. Po skomplikowanej zmianie uprawnień, za pomocą polecenia audytu jesteśmy w stanie sprawdzić czy nasze zmiany działają tak jak chcemy.\nTypy audytu:\naudyt polceń, audyt wykorzystania pewnych rodzajów poleceń, np. AUDIT TABLE, AUDIT CREATE ROLE.\naudyt na konkretnym obiekcie, np. AUDIT INSERT ON table3\nFGA, bardziej zaawansowane, możemy decydować czy chcemy tworzyć wpis audytu na SELECT na tabeli, ale możemy zdecydować czy chcemy zobaczyć na których kolumn, a nawet wierszach, np. jeśli ktoś robi SELECT na tabeli prezesa\nRezultaty audytu zapisywane są, w zależności od parametru AUDIT_TRAIL (domyślnie NONE), jeśli wpis 'chwyci' zapisywany jest on w schemacie pliku textowego lub XML lub w system event log, lub w bazie danych w specyficznych widokach.",
    "scale": 1
},
{
    "question": "W3: BONUS - uprawnienia w bazach PBD i CDB?",
    "type": "long_open",
    "correct_answer": "Użytkownicy oraz role COMMON albo LOCAL.\nUżytkownicy systemowi domyśli typu SYS, SYSOPER są użytkownikami COMMON - widziani we wszystkich bazach. W ROOCIE i wszyskich pluggable. Są przechowywani w ROOCIE. Aby użytkownik był public musi mieć przedrostek c##\nUżytkownicy lokalni, są tylko w obrębie danych baz pluggable, unikalni tylko w obrębie danej bazie. Nazwy nie mogą się zaczynać z c##\nZ rolami i profilami to samo, tylko common user musi posiadać common profile.\nDawanie priviliges. Można lokalnie albo globalnie. Użytkownik common może dostać uprawnienie globalnie albo lokalnie. Rola może dostać uprawnienie lokalnie i globalnie. A rolę globalną możemy nadać globalnie albo lokalnie. Role lokalnie nadawane tylko lokalnie. \nAudyty: możemy specyfikować czy chcemy globalnie czy lokalnie. Audyty globalne przechowywane w ROOCIE, lokalne w lokalnej bazie. Lokalny audyt odnosi się do lokalnych i globalnych użytkowników.\nPodczas zarządzania bierzemy 2 rzeczy pod uwagę: \n- niezawodność i trwałość przechowywannia danych\n- preformance\nNigdy nie możemy mieć dwóch naraz, zawsze jakiś tradeoff. Aby poprawić performance, będzie nadawać więcej uprawnień do poszczególnych segmentów i schematów, ale nie będzie poprawiało to niezawodności. ",
    "scale": 1
},
{
    "question": "W4: Wymień warstwy struktur składowania w bazie danych Oracle oraz struktury należące do poszczególnych poziomów.",
    "type": "long_open",
    "correct_answer": "logiczna/użytkownika - schematy, w ramach schematów tworzone komponenty przez użytkownika\nwewnętrzna - Baza danych (nie ma logicznej bazy danych, baza danych rozumiana jest jak zbiór danych wszystkich użytkowników i dane systemowe) może być też pluggable albo kontenerowa, przestrzenie tabel, segmenty, ekstenty\nfizyczna - pliki danych, przechowywane w systemie plików oraz bloki dyskowe, ostatecznie wszystko jest składowane w plikach. Oracle ma możliwość aby przechowywać tą warstwę bez systemu operacyjnego. Możemy np. dać surowy dysk Oraclowi, i on samemu na wyłączność, ponieważ Oracle ma również swój system plików.",
    "scale": 1
},
{
    "question": "W4: Omów, czym jest: schemat, przestrzeń tabel, segment, ekstent, blok bazodanowy. Omów zależności pomiędzy nimi",
    "type": "long_open",
    "correct_answer": "schemat - wszystkie obiekty bazodanowe należące do danego użytkownika. Zawsze zakładany dla danego użytkownika, nazwa schematu zawsze odpowiada nazwie użytkownika, możemy podglądać inne schematy jeśli posiadamy wymagane uprawnienia. W ramach schematu, nie można utworzyć czegoś poza schematem.\nprzestrzeń tabel - Wydzielone obszary, ktore są niezależnie zarządzane, z poziomu przestrzeni tabel zarządzania się plikami danych, są również predefiniowane przestrzenie tabel Przestrzeń tabel tak naprawdę nie składa się ze schematów, ponieważ dany użytkownik może mieć ustaloną quotę w różnych przestrzeniach tabel, więc tak naprawdę użytkownik może zmieniać dane nie w swoim schemacie, domyślnie użytkownik przypisany do przestrzeni tabel users\nsegment - W momencie gdy użytkownik pisze dowolne polecenie tworzące logiczną strukturę np. CREATE TABLE, na poziomie wewnętrznym tworzonych jest jeden lub więcej segmentów. Jeżeli jest to zwykła tabela, która nie zawiera klucza głównego zostanie stworzony jeden segment. Jeśli zawiera klucz główny zostaną stworzone 2 segmenty. Jeśli tabela zawiera wbudowaną tabelę wewnętrzną, lub zawiera Large Objects, wtedy na podstawie takiej tabeli zostanie stworzonych wiele segmentów. Na poziomie segmentu można zarządzać alokowaniem tego jak dane magą być wpisywane w poszczególne pliki. Dla danego segmentu możemy skorzystać z domyślnych ustawień, gdy wpiszemy polecenie CREATE TABLE gdzie zostanie utworzony segment z domyślnymi wartościami przypisanymi do przestrzeni tabel, w której jest on utworzony. Jest też możliwość aby wyspecyfikować jak segment będzie składowany i w jaki sposób będą alokowane kolejne przestrzenie na ten segment. Tabele mogą być dzielone na klastry i partycje, i wtedy segmenty będą dzielone odpowiednio.\nekstent - jest to element alokacji, baza danych nie alokuje pojedyńczych bloków, tylko jednostką alokacji jest ekstent, może się składać z jednego bloku, bądź może składać się z większej ilości bloków bazodanowych (np. 16, 32). Na poziomie wewnętrznym zarządzamy ekstentami, zarządzamy tym jakie są rozmiary ekstentów, dla różnych przesteni tabel mogą być różne rozmiary ekstentów, w definicji danego segmentu możemy zdefiniować jak duże ekstenty będą tworzone, nie muszą być tych samych rozmiarów, np. jeden duży, wiele małych.\nblok bazodanowy - składa się z określonej liczby bloków dyskowych, wartość domyślna - 8. Możemy również zarządzać na poziomie bloków. Od góry bloków, w nagłówku pisane są transakcje, od dołu wpisywane są dane.\n\nEXTENDED:\nschemat - wszystkie elementy schematów składowane są w przestrzeniach tabel za pomocą segmentów. Odwołanie do schematów może być jawne lub niejawne, np. przy CREATE TABLE możemy podać lub nie nazwę schematu. Nazwy obiektów nie muszą powtarzać się w obrębie jednego schematu. \ndatabase - kontenerowe i pluggable, w oracle 19 i 21 jest możliwość żeby stworzyć tak jak kiedyś jedną dużą bazę danych tak jak we wcześniejszych wersjach oracle.\nprzestrzeń tabel - mogą być niezależnie zarządzane, mogą być ustawiane read-only i on-line i off-line. Pojedyńczy plik danych jest zawsze przypisany do jednej przestrzeni tabel!!!!!!!. Mamy kilka typów przestrzeni tabel: na dane systemowe, na dane użytkownika, undo, na dane tymczasowe. Ze względów niezawodnościowych lepiej jest rozdzielać dane systemowe od danych użytkownika, a także rozdzielać dane użytkownika i dane undo (jeśli przestrzeń tabel użytkownika zostanie zapełniona przez jakiś atak to przestrzeń undo nietknięta). Poleca się aby odzielić indexy od tabel. Dzięki temu można podnieść performance. Absoultne minimum przestrzeni tabel to 3. Można rozdzielić za pomocą tablespaców dane hurtowniane a transakcyjne. \nMechanizm undo i redo - osobne segmenty składujące dane zanim zostały zacommitowane, aby była możliwa operacja rollback, jest to robione po to żeby zapewnić tryb izolacji transkacji midcommited, ponieważ w tym trybie można czytać tylko dane które zostały zacommitowane, dlatego jak inny użytkownik będzie czytał dane z tabeli na której jest transakcja do odczyta z undo. A redo (pliki dziennika powtórzeń) jest po to aby bazę danych w trybie niespójnym aby powtórzyć lub wycofać transakcję, które nie zakończyły się, nie zostały zapisane podczas awarii bazy danych. Są też osobne buffory dla redo i undo.\nzarządzanie przestrzenią tabel - odzielamy dane trwałe od danych tymczasowych, odzielamy dane szybkozmiennie od wolnozmiennych, odzielamy dane OLAP od OLTP, odzielamy tabele od indexów, odzielamy historyczne partycje od obecnych.\nsegment - wewnętrzna reprezentacja obiektów tworzonych przez użytkownika. Przypisany do konkretnej przestrzeni tabel. Możemy mieć typy segmentów: typy zawierające danych (table, table partition, cluster, nested table, LOB segment), typy zawierające indexy (index, index-based table, index partition, LOB index), tymczasowy i undo.\nekstent - pojedyńcza jednostka alokacji w plikach danych. W momencie kiedy segment jest tworzony, updatowany, dane jego są usuwane, to kolejne extenty będą tworzone. ",
    "scale": 1
},
{
    "question": "W4: Wymień i omów rodzaje plików bazy danych, instancji i serwera Oracle.",
    "type": "long_open",
    "correct_answer": "Pliki danych - zawierają bloki danych, słownik, dane użytkowników, uprawnienia. Przypisane są do jednej przestrzeni tabel. Mogą posiadać dane z różnych segmentów. Alokacja przestrzeni w plikach danych jest robiona za pomocą ekstentów. Posiada on nagłowek i potem wolne i zajęte ekstenty.\nPlik kontrolny - początkowo tylko jeden, ale POWINIEN być multiplikowany , jeśli plik kontrolny się uszkodzi to nie ma możliwości dostępu do danych. Jest to kluczowy plik w dostępu do danych. Powinien być powielany na różnych dyskach. Zawiera on informacje o statusie danej bazy, ostatnim checkpoincie, adresy do plików danych, adresy do plików dziennika powtórzeń. \nPliki dziennika powtórzeń - kolejne wpisy zawierające informacje o tym jakie zmiany zostały zrobione na bazie danych (poprzednia wartość -> aktualna wartość). Commit wymusza zapisanie danych z tego bufora do plików dziennika powtórzeń, przy checkpoincie pliki dziennika powtórzeń zapisywane są do plików danych.\nPassword files - Użytkownicy mający SYSDBA, SYSOPER, SYSAMS, SYSBACKUP, SYSDG mają swoje hasła w pliku haseł. Pliki haseł można tworzyć za pomocą ORAPWD.\nInitialization parameter file - plik parametrów inicjalizacyjnych, w wersji binarnej, tak jest czytany przy starcie instancji, jest też wersja tekstowa dla człowieka, którą można zedytować i przekonwertować z powrotem na binarną. Część parametrów można zmienić w trakcie życia instancji, czyli może być rozbieżność między tym plikiem a konfiguracją instancji. Trzeba w sposób przemyślany dokonywać takich zmian w locie. Z biegem wersji jest tam coraz mniej inicjalizacyjnych parametrów, ponieważ są one dobierane automatycznie, albo ma domyślne wartości.\nArchive files - Kopie zapasowe (wszystkich rodzajów), w tym automatycznie tworzone kopie plików dziennika powtórzeń (w trybie ARCHIVELOG)\nBackup files - :) \nLogs - Logi systemowe, logi błędów, logi śledzenia (monitorowania) instancji",
    "scale": 1
},
{
    "question": "W4: Omów sposób alokacji ekstentów",
    "type": "long_open",
    "correct_answer": "Mamy jedną przestrzeń tabel (users), domyślnie jeden plik danych, wszystkie dane wszystkich użytkowników znajdują się w tym jednym pliku. Jak będzie wyglądała alokacja ekstentów w tym pliku?\nJest jakiś nagłowek tego pliku.\nUżytkownik 1 stworzył tabelę 1 - ekstent na tabelę 1, 1 uzytkownika\nUżytkownik 2 stworzył tabelę 2 - ekstent na tabelę 2, 2 użytkownika\nUżytkownik do 1 tabeli wpisał 2 miliony danych - duży ekstent na 2 miliony danych\nWszystko jest składowane łącznie. I te dane nie są wszystkie koło siebie tylko są rozrzucone. (te tiles poniżej do są osobne ekstenty) wszystko to oczywiście może być dynamicznie alokowane i dealokowane. Może być tak że mamy dane z tabeli 1,2,3. W momencie gdy te dane się zmniejszą, dane wcześniej zajmowane zostaną zwolnione. Dlatego może występować problem fragmentacji. Jeśli np. będzie dużo updatów i ekstent nagle się zapełni, to może wystąpić sytuacja w której będzie trzeba nowe dane zapisać do nowego ekstentu.",
    "scale": 1
},
{
    "question": "W4: Omów budowę i sposób parametryzowania bloku bazy danych Oracle.",
    "type": "long_open",
    "correct_answer": "sterowane za pomocą parametrów instancji, na tych prezkach wbrew pozorom jest to dobrze wyjaśnione.",
    "scale": 1
},
{
    "question": "W4: Jakie różnice w konfiguracji struktur składowania są zalecane dla baz danych o charakterystyce OLAP i OLTP?",
    "type": "long_open",
    "correct_answer": "Duże bloki danych, duże ekstenty dla OLAP. Dla OLTP bloki danych i ekstenty będą mniejsze. Dla OLTP nadawanie więcej uprawnień dla poszczególnych segmentów i schematów. Można zwiększyć liczbę transkacji na blokach baz danych - OLTP. Mniejsza dla OLAP. Można rozdzielić za pomocą tablespaców dane hurtowniane a transakcyjne.",
    "scale": 1
},
{
    "question": "W5: Wyjaśnij różnicę pomiędzy kopią zapasową struktur logicznych oraz fizycznych bazy danych",
    "type": "long_open",
    "correct_answer": "Logiczne służą do tego aby robić backupy danych użytkownika, lub przenosić dane między bazami danych, a fizyczne aby backupować fizyczne struktury, które Oracle używa do przechowywania danych, dlatego jest bardzo dobry w przypadku zgubionych plików bazy danych. Używają innych narzędzi RMAN - fizyczne, Oracle Data Pump - logiczne. Oba typy kopii zapasowych posiadają możliwość przywrócenia bazy danych do przeszłego stanu, gdzie w fizycznej kopii zapasowej możemy wrócić do dowolnego stanu o ile mamy odpowiednie backupy i zarchiwizowane pliki dziennika powtórzeń, a w przypadku logicznej wystarczy mieć plik z którego chcemy zaimportować dane wcześniej wyeksportowane.",
    "scale": 1
},
{
    "question": "W5: Omów podział kopi zapasowych (struktur fizycznych) ze względu na format zapisu",
    "type": "long_open",
    "correct_answer": "Storage format\nkopia obrazu - dosłowna kopia pliku bazy danych, posiada puste bloki, możne zostać zamieniony z oryginalnym plikiem\nBackup set - używany aby zmniejszyć rozmiar backupu (wyżej mamy te puste bloki), ponieważ działa jak kopia obrazu, ale pomija puste bloki. Nie może być używany do synthetic full backupu",
    "scale": 1
},
{
    "question": "W5: Omów podział kopi zapasowych (struktur fizycznych) ze względu na zawartość",
    "type": "long_open",
    "correct_answer": "Contents\nFull backup - wszystkie dane zapisane są w plikach backupu, z pustymi blokami\nIncremental backup \nLevel 0 - taki sam jak full backup, tylko może być użyty jako podstawa do następnych incremental backupów poziomu 1\nLevel 1 cumulative - tylko bloki które zmieniły się od ostatniego Level 0 backup\nLevel 1 - tylko bloki od ostatniego inremental backupu - Level 0 albo 1\nSynthetic full backup - Level 0 backup z backupami Level 1 zaaplikowanymi do niego",
    "scale": 1
},
{
    "question": "W5: Omów podział kopi zapasowych (struktur fizycznych) ze względu na spójność danych (jakie kopie można wykonywać w jakim trybie działania bazy?)",
    "type": "long_open",
    "correct_answer": "Consistency (nie wiem czy redo logi to to samo co dziennik powtórzeń/pliki dziennika powtórzeń więc użyłem bezpieczniejszej nazwy)\nConsistent/offline backup\nConsistent - przechowuje transaction-consistent data (nie wiem dokładnie co to jest ale zakładam że dane muszą być zgodne z transakcjami jakie są wykonywane) (może można to nazwać spójnymi danymi)\nOffline - Consistent omawiany wyżej nakada na nas warunek żeby baza danych była wyłączona aby móc przeprowadzić consistent backup\nnie potrzebuje media recovery po przywróceniu oryginalnego pliku\njak przywrócimy bazę danych z pliku, to będzie zawierała ona tylko dane z momentu backupu\nInconsistent/online backup\nInconsistent - w porównaniu do offline backupu, ten backup zawiera dane w transaction-inconsistent state (czyli pewnie nie wszystkie transakcje są zakończone albo zacomittowane) (może można to nazwać niespójnymi danymi)\nOnline - może być wykonany podczas działania bazy danych\nale przez to wymaga media recovery po przywróceniu oryginalnego pliku\njeśli media recovery zostanie użyte to baza danych po przywróceniu informacji z pliku nie tylko będzie zawierała dane z momentu backupu ale też dane do momentu awarii bazy danych\nMedia recovery\nreapplies zmiany zapisane na incremental level 1 backupach i zarchiwizowanych i obecnych redo logach\nzarchiwizowane i obecne redo logi są bardzo ważne, ponieważ media recovery może potem ich użyć do repplying zmian z zacommitowanych transakcji których nie ma w bazie danych przywróconej z pliku\nMedia recovery możliwa jest tylko gdy baza danych jest w trybie ARCHIVELOG, ponieważ tylko tam zarchiwizowane redo logs będą dostępne",
    "scale": 1
},
{
    "question": "W5: Omówić podobieństwa i różnice mechanizmów 'Point-in-time recovery' oraz 'Flashback database'",
    "type": "long_open",
    "correct_answer": "Point in time recovery:\numożliwia na przywrócenie bazy danych do przeszłego stanu, o ile mamy odpowiednie backupy i zarchiwizowane pliki dziennika powtórzeń\nOracle Flashback:\ndaje możliwość dostępu do poprzednich stanów danych bazy danych Oracle bez użycia Point in time media recovery, co wiąże się z tym że nie musimy przywracać całej bazy danych do poprzedniego stanu aby mieć dostęp do poprzednich danych nie opiera się on na plikach backupu tylko na undo operacji na danych, możemy w parametrze UNDO_RETENTION na jak długo będą trzymane dane na undo\n\nW obdydwu mechanizmach jesteśmy w stanie wrócić do wybranego momentu w czasie, wersji, ale w flashbacku jesteśmy też w stanie dostać wszystkie wersje z jakiegoś przedziału czasu. W point in time i flashback database jesteśmy w stanie przywrócić całą bazę danych do danego punktu w czasie, w tym przypadku działają bardzo podobnie.",
    "scale": 1
},
{
    "question": "W5: Wymień i podaj zastosowanie poszczególnych mechanizmów flashback",
    "type": "long_open",
    "correct_answer": "Flashback query - działa poprzez odzyskiwanie danych takie jakie były w przeszłości, aby je użyć stosujemy po prostu SELECT z dodatkiem AS OF TIMESTAMP (czas). Możemy wydobyć dosłowne dane z przeszłości a nie stan (?bazy danych możliwie).\nFlashback version query - tak jak poprzedni bierzemy dane za pomocą SELECTU, ale w tym wypadku nie dostajemy danych ze specyficznego punktu w czasie tylko wszystkie wersje danych, które były w bazie w danym odstępie czasu, wersji.\nFlashback transaction query - dostępny poprzez widok FLASHBACK_TRANSACTION_QUERY. Widok ten przechowuje dane o wszystkich transakcjach i zmianach na danych użytych w tych transakcjach. Możemy z tego widoku dostać np. użytkownika który wykonał transakcje i kod SQLowy który wycofa wszystkie zmiany zrobione w tej transakcji.\nFlashback Table - przywraca daną tabelę w wybrany punkt w czasie/SCN. Aby móc używać Flashback table należ włączyć opcję ROW MOVEMENT.\nFlashback Drop - przywraca tabelę z kosza, która została zDROPowana. Aby ten flashback działał, musimy mieć ustawione RECYCLEBIN na ON, na samym początku możemy zobaczyć w USER_RECYCLEBIN i czy tam jest jakaś tabela i potem z binID do niej wrócić, albo możemy po prostu podać nazwę tabeli.\nFlashback database - używany za pomocą RMANA, przywraca bazę danych do wybranego punktu w czasie/SCN.",
    "scale": 1
},
{
    "question": "W7: Poziomy optymalizacji wydajności w Oracle. Zasady optymalizacji wydajności.",
    "type": "long_open",
    "correct_answer": "poziom zapytań, możemy zmieniać samo zapytanie i zmieniać sposób wywołania tego zapytania na poziomie aplikacji, na poziomie aplikacji możemy podzielić jedno zapytanie na mniejsze, albo jedno duże zapytanie scalić, możemy część przetwarzania przerzucić na maszynę serwerową. Większość zapytań (około 80%) to kwestia nieoptymalnych zapytań. Czasami nawet nie można potrzeby na dane zapytanie.\npoziom logicznej struktury bazy danych, normalizacja, aby unikać nadmiarowości aby nie powodować anomalii aktualizacji. Postacie normalne służyły do tego aby dane nie były nadmiarowo przechowywane. Z perspektywy wydajności czasami celowo wprowadza się redundancję i nadmiarowość, aby zapewnić wydajność\nkonfiguracji środowiska Oracle, działa instancji, działania bazy danych, np. ilość ekstentów, jak je alokować, więcej czy mniej, kiedy zwalniać tą przestrzeń, jakie bufory i ich rozmiary, pamięć operacyjna, algorytmy wykorzystania buforów, liczba procesów serwera. Jest to bardzo ważne dla bazy danych z danymi hurtownianymi i transakcyjnym, i w takim wypadku możliwie że będzie konieczne rozdzielenie tych danych między sobą fizycznie np. oddzielnie przestrzenie tabel z osobnymi charakterystykami.\nśrodowisko uruchomienia Oracle, brakuje zasobów pamięciowych, za mało procesorów, problem systemu operacyjnego (windows wymuszający aktualizację), (wersje, patche, dodatkowe moduły) (Oracle), konfiguracja połączenia sieciowego (za mało portów)",
    "scale": 1
},
{
    "question": "W7: Omów narzędzia optymalizacji w Oracle i obszary ich zastosowań.",
    "type": "long_open",
    "correct_answer": "AWR - automatic workload repository - mechanizm który występuje od wersji 9, i służy do tego żeby gromadzić statystyki o bazie. Odpowiednio ustatwiony, okresowo zbiera określone statystyki aby móc zobaczyć co się dzieje. \nADDM - automatic database diagnostic monitor - analizuje AWR i okresowo zgłasza błędy administratorowi (Działanie proaktywne).\nDBMS_STATS - we wcześniejszych wersjach Oracle, obecnie też jest, kiedyś miał większe znaczenie, w tej chwili służy aby zbierać statystyki o poszczególnych tabelach\nOracle advisors: (to po prostu możemy nam wskazać top 10 najbardziej obciążające bazę zapytań \nMemory advisor \nSQL tuning advisors\nSQL access advisors\nPartioning advisor\nSQL performance analyzer\nAlerty - automatyczne albo programowalne przez administratora, również działanie proaktywne, aby okresowo sprawdzać i alarmować\n\nTrzeba być rozważnym jak chodzi o tunowanie instancji Oracle, nie optymalizować jeśli naprawdę nie widać potrzeby.",
    "scale": 1
},
{
    "question": "W7: Na czym polega różnica między akcyjną a proaktywną optymalizacją wydajności?",
    "type": "long_open",
    "correct_answer": "Firefighting - sytuacja kiedy już mamy zgłoszony problem z wydajnością, że są problemy z zapytaniami, z dostępem (dosłownie gasimy pożar). \nEXTENDED:\nWażne jest aby zapytać się o detale:\nco dokładnie jest za wolne\nkiedy i w jakich przypadkach i czy jest to powtarzalne\njakie poprawy są spodziewane\nczy inni mają ten sam problem\nco się zmieniło od czasu kiedy działało lepiej\nczy na pewno trzeba wykonać to query\nsprawdzić reporty z danego okresu czasu z narzędzi opisanych w pytaniu 2 (ADDM jest bardzo użyteczny)\nKolejność diagnozowania błędu - zapytanie -> aplikacja -> środowisko Oracle -> instancja Oracle\nZmieniać tylko jedna rzecz na raz.\nNajpierw testować na testowym serwerze.\nSprawdzić improvement na testowym a potem na produkcyjnym serwerze.\nProaktywne - monitorowanie wydajności na bieżąco, aby zauważyć starzenie się instancji, np. ze wzrostem wolumenów, użytkowników, danych wydajność się pogarsza i wtedy podjąć działanie. Używanie ADDM. Używanie alertów.\nEXTENDED:\nplanujemy, próbujemy zaprojektować wydajność\nCo można zrobić?\nJak analizujemy działanie instancji zawsze musimy podać początek i koniec czasu w jakim chcemy ją analizować. \nMożna obniżać obciążenie w danych okresach czasu. Może zarządzać zasobami w zależności od czasu. Zrównoleglanie.\n(więcej nie mówiła w porównaniu z tym co jest na slajdach)\nmożna sprawdzać też zapytania w krytycznych momentach czasowych, oraz sprawdzać plany zapytania zapytań.\nWażne też jest używanie tych wszystkich raportów, alertów z tych narzędzi z pytania nr 2.",
    "scale": 1
},
{
    "question": "W7: Jak jest przetwarzane w Oracle: zapytanie SELECT, polecenia DML, polecenie COMMIT.",
    "type": "long_open",
    "correct_answer": "SELECT - \nParsowanie: \nPoszukiwanie w poprzednich wykonywanych poleceniach w Shared Pool w Library Cache (plan zapytania wcześniej wybrany, zoptymalizowany, wybrany spośród wielu). Ważne aby zbiór tych przygotowanych wcześniej zapytań mieścił się w Shared pool.\nsprawdzenie składni - sprawdzenie poprawności (może nawet jest wcześniej np. przez SQL developera?????)\nsprawdzenie nazewnictwa obiektów, używa słownika danych Data dictionary Cache\nblokowanie obiektów używanych w czasie analizy, nie można ich modyfikować podczas query, nie będą na nich działać polecenia DDL\nsprawdzenie uprawnień, znowu z Data dictionary Cache\ntworzenie planu wykonania zapytania, tworzy wiele wariantów, ocenia je i wybiera najlepszy z nich i zapisuje w buforze\nWykonanie\nsprawdza dane w buforze danych (LRU)\nczytanie danych z plików danych lub bufora danych\notwarcie kursora (????)\nfetchowanie(proces serwera)\nsortowanie(proces serwera)\nwysłanie z kursora do procesu klienta (prędkość zależy od konfiguracji środowiska sieciowego)\nPrzetwarzanie zapytania DML \nAnaliza - jak w zapytaniach \nWykonanie - \njeżeli dane nie są w buforze, następuje odczyt danych z plików i zapisanie ich do buforów danych i wycofania; \nzałożenie blokad na rekordy; \nmodyfikacja bufora danych - nowe wartości i bufora wycofania - poprzednie wartości; \n('brudny blok' - dane w pamięci różnią się od danych w plikach na dysku).\nrejestracja zmian w buforze dziennika powtórzeń (które bloki w obu buforach są zmienione); \nCOMMIT \nPrzetwarzanie polecenia COMMIT \nmechanizm 'fast commit' \nnumer SCN - system change number \nkroki: \nZapis o commitcie(?) z numerem SCN (system change number) w buforze dziennika powtórzeń (REDO LOG BUFFER) \nLGWR zapisuje bufor dziennika powtórzeń do pliku (REDO LOG)  \nUżytkownik jest informowany o zakończeniu commit \nZapis o zakończeniu commit’u. \nzapis danych do plików jest niezależny od polecenia commit, może nastąpić przed lub po wykonaniu commit. \nzapis tylko do dziennika powtórzeń sprzyja wydajności, poniewaz zapis do plików danych jest kosztowny i inne transakcje mogą mieć większy priorytet i czekać, przez co oracle wybierze czas na zapisanie tego do pliku, tak aby było najwydajniej \nWhen a user issues a COMMIT statement, LGWR puts a commit record in the redo log buffer and writes it to disk immediately, along with the transaction's redo entries. The corresponding changes to data blocks are deferred until it is more efficient to write them. This is called a fast commit mechanism. The atomic write of the redo entry containing the transaction's commit record is the single event that determines the transaction has committed. Oracle returns a success code to the committing transaction, although the data buffers have not yet been written to disk",
    "scale": 1
},
{
    "question": "W7: Analiza planu zapytania - cele, metody, operacje.",
    "type": "long_open",
    "correct_answer": "Rola PLUSTRACE wymaga jest do zobaczenia planu wykonania zapytania.\nWarto czyścić tabele planów wykonania zapytania co jakiś czas.\nPrzez śledzenie zapytań, ich wydajność może spaść o 25%\nCzytamy od prawej do lewej z góry na dół.\nParametry jakie możemy spotkać:\nTable access full - fajne jeśli tabela jest mała, słaba jeśli jest duża, warto rozważyć wprowadzenie indeksów\nTable access by index rowid - najbardziej efektywna metoda, idziemy do fizycznego adresu wiersza\nindex unique scan - szybszy niż range scan bo tam jest wiele ścieżek a w tym przechodzimy po jakimś B drzewie\nindex range scan - może to oznaczać że indeks jest nieodpowiednie utworzony.\nHash key access - w przypadku partycji\nZłączenia:\nnested loop - jedna tabela i jedziemy po wierszu, i dla każdego wiersza przejeżdżamy wszystkie wiersze z drugiej tabeli jeśli odnosimy się to wielu tabel to nieefektywne, jeśli te tabele są małe to spoko, oceniamy na podstawie ilości użytych wierszy\nsort merge join - najpierw sortujemy i po pewnym atrybucie złączamy dwie tabele, jeżeli są podonych rozmiarów soft merge join szybszy, jeśli różnych to nested loop lepszy\nhash join - ?????\ncartesian join - złączamy wszystko ze wszyskim, jest prawdopodobieństwo że błąd ludzki, szukamy skanowania dużych tabel wtedy\nCzego szukamy w planach wykonania zapytania?\nbłędów człowieka\nszukamy błędów optymalizatora, jeśli wykonujemy duże ładowanie danych, to warto zaktualizować statystyki aby zaktualizować plany wykoania zapytań\nszukamy zalet Oracla, jak je znajdziemy to wiemy że zapytanie jest spoko\n\nCo powinno nas niepokoić?\n- duże skany tabel\n- cartesian joiny\n- unselective range scan ?? (brak indexu)\n- zły order joinów\n- zagnieżdżone pętle\n- nieefektywne filtry\n\nDobre strony zapytań:\n- jak najwcześniejsza selekcja\n- jak najszybsza projekcja\n- joiny najpóźniej jak można (kartezjany szczególnie)\n- unia dopiero po wszystkich joinach\n- kolejność złączeń odpowiada liczby wierszy",
    "scale": 1
},
{
    "question": "W7: Różnica między optymalizatorem kosztowym a regułowym",
    "type": "long_open",
    "correct_answer": "Regułowy - do oracla 9i, jeżeli selektywność zapytania jest powyżej 50% to skanuj całą tabelę, a nie używaj indeksów, jeśli selektywność zapytania jest mniejsza niż 10% użyj indeksów. Optymalizacja zapytania na podstawie reguł. Mamy większą kontrolę nad tym co robimy.\nKosztowy - od oracla 7, teraz już jedyny, ma statystyki na tabelach, bierze je pod uwagę, oblicza selektywność, ilość zwracanych wierszy i sam dobiera reguły (dynamicznie). Uwzględnia całą konfigurację instancji. Szacuje koszt i wybiera plan o najmniejszym koszcie. Jest to automat.",
    "scale": 1
}
    ]
}